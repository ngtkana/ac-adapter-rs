var searchIndex = JSON.parse('{\
"avl_tree":{"doc":"AVL …","t":"DDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["AvlTree","IntoIter","Iter","append","back","back_mut","binary_search","binary_search_by","binary_search_by_key","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","cmp","default","eq","eq","equivalent","fmt","from","from","from","from_iter","front","front_mut","get","get_mut","hash","index","insert","into","into","into","into_iter","into_iter","into_iter","into_iter","is_empty","iter","len","lower_bound","new","next","next","next_back","partial_cmp","partition_point","pop_back","pop_front","push_back","push_front","remove","split_off","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","upper_bound"],"q":[[0,"avl_tree"],[68,"core::option"],[69,"core::result"],[70,"core::cmp"],[71,"core::borrow"],[72,"core::ops::function"],[73,"core::clone"],[74,"core::cmp"],[75,"core::fmt"],[76,"core::hash"],[77,"core::hash"]],"d":["AVL 木本体です。","<code>AvlTree</code> …","<code>AvlTree</code> …","<code>other</code> のすべての要素を <code>self</code> …","列の末尾の要素があれば返し、空なら <code>None</code> …","列の末尾の要素があれば返し、空なら <code>None</code> …","<code>value</code> …","<code>f</code> が <code>Equal</code> …","<code>f</code> が <code>Equal</code> …","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","列の先頭の要素があれば返し、空なら <code>None</code> …","列の先頭の要素があれば返し、空なら <code>None</code> …","<code>other</code> の第 <code>index</code> 成分があれば返し、なければ …","<code>other</code> の第 <code>index</code> 成分があれば返し、なければ …","","","<code>other</code> の第 <code>index</code> 成分に <code>value</code> を挿入します。","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","空列であれば <code>true</code> を返します。","…","列の要素数を返します。","<code>value</code> …","空列を構築します。","","","","","","…","…","列の末尾に要素を追加します。","列の先頭に要素を追加します。","<code>other</code> の第 <code>index</code> …","<code>other</code> の第 <code>index</code> 成分以降を切り離します。","","","","","","","","","","","<code>value</code> …"],"i":[0,0,0,1,1,1,1,1,1,20,21,1,20,21,1,1,1,1,1,1,1,1,1,20,21,1,1,1,1,1,1,1,1,1,20,21,1,20,21,1,1,1,1,1,1,1,20,21,20,1,1,1,1,1,1,1,1,1,20,21,1,20,21,1,20,21,1,1],"f":[0,0,0,[[[1,[-1]],[1,[-1]]],2,[]],[[[1,[-1]]],[[3,[-1]]],[]],[[[1,[-1]]],[[3,[-1]]],[]],[[[1,[-2]],-1],[[5,[4,4]]],6,[[7,[-1]]]],[[[1,[-1]],-2],[[5,[4,4]]],[],8],[[[1,[-1]],-2,-3],[[5,[4,4]]],[],6,8],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],9],[[-1,-2],2,[],[]],[[[1,[-1]],[1,[-1]]],10,6],[[],[[1,[-1]]],[]],[[[1,[-2]],[11,[-1]]],12,[],[[13,[-1]],13]],[[[1,[-1]],[1,[-1]]],12,13],[[-1,-2],12,[],[]],[[[1,[-1]],14],15,16],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,[[1,[-2]]],17,[]],[[[1,[-1]]],[[3,[-1]]],[]],[[[1,[-1]]],[[3,[-1]]],[]],[[[1,[-1]],4],[[3,[-1]]],[]],[[[1,[-1]],4],[[3,[-1]]],[]],[[[1,[-1]],-2],2,18,19],[[[1,[-1]],4],[],[]],[[[1,[-1]],4,-1],2,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[],[]],[[[1,[-1]]],[],[]],[[[1,[-1]]],12,[]],[[[1,[-1]]],[[20,[-1]]],[]],[[[1,[-1]]],4,[]],[[[1,[-2]],-1],4,6,[[7,[-1]]]],[[],[[1,[-1]]],[]],[[[20,[-1]]],3,[]],[[[21,[-1]]],3,[]],[[[20,[-1]]],3,[]],[[[1,[-1]],[1,[-1]]],[[3,[10]]],22],[[[1,[-1]],-2],4,[],8],[[[1,[-1]]],[[3,[-1]]],[]],[[[1,[-1]]],[[3,[-1]]],[]],[[[1,[-1]],-1],2,[]],[[[1,[-1]],-1],2,[]],[[[1,[-1]],4],[[3,[-1]]],[]],[[[1,[-1]],4],[[1,[-1]]],[]],[-1,-2,[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,23,[]],[-1,23,[]],[-1,23,[]],[[[1,[-2]],-1],4,6,[[7,[-1]]]]],"c":[],"p":[[3,"AvlTree",0],[15,"tuple"],[4,"Option",68],[15,"usize"],[4,"Result",69],[8,"Ord",70],[8,"Borrow",71],[8,"FnMut",72],[8,"Clone",73],[4,"Ordering",70],[15,"slice"],[15,"bool"],[8,"PartialEq",70],[3,"Formatter",74],[6,"Result",74],[8,"Debug",74],[8,"IntoIterator",75],[8,"Hash",76],[8,"Hasher",76],[3,"Iter",0],[3,"IntoIter",0],[8,"PartialOrd",70],[3,"TypeId",77]]},\
"binary":{"doc":"二分法（ダブリング）をします。","t":"IKKKFKF","n":["Pow","is_nonone","is_nonzero","is_odd","operator_binary","shr1","value_binary"],"q":[[0,"binary"],[7,"core::ops::function"]],"d":["…","<code>*x != 1</code>","<code>*x != 0</code>","<code>x &amp; 1 == 1</code>","aⁿ(x) を計算します。","<code>self &gt;&gt;= 1</code>","aⁿを計算します。"],"i":[0,2,2,2,0,2,0],"f":[0,[-1,1,[]],[-1,1,[]],[-1,1,[]],[[-1,-2,-3,-4,-5],-3,[],2,[],3,3],[-1,4,[]],[[-1,-2,-1,-3],-1,[],2,3]],"c":[],"p":[[15,"bool"],[8,"Pow",0],[8,"FnMut",7],[15,"tuple"]]},\
"bitvec":{"doc":"Boolean 配列を <code>u64</code> …","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["BitVec","Iter","bitand_assign","bitor_assign","bitxor_assign","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","default","eq","equivalent","fmt","format","from","from","from_01str","from_iter","hash","into","into","into_iter","into_iter","is_empty","iter","len","new","next","push","set","shl_assign","shl_assign","shl_assign","shl_assign","shl_assign","shl_assign","shl_assign","shl_assign","shl_assign","shl_assign","shl_assign","shl_assign","shr_assign","shr_assign","shr_assign","shr_assign","shr_assign","shr_assign","shr_assign","shr_assign","shr_assign","shr_assign","shr_assign","shr_assign","test","to_owned","to_string","try_from","try_from","try_into","try_into","type_id","type_id","unset"],"q":[[0,"bitvec"],[66,"core::fmt"],[67,"core::fmt"],[68,"core::iter::traits::collect"],[69,"core::hash"],[70,"core::option"],[71,"core::result"],[72,"core::any"]],"d":["Boolean 配列を <code>u64</code> …","ビットを順に <code>bool</code> を返すイテレータです。","","","","","","","","","","","","","","指定したフォーマットの <code>String</code> …","Returns the argument unchanged.","Returns the argument unchanged.","“01” 文字列から構築します。","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","長さを返します。","ビットを順に <code>bool</code> …","長さを返します。","サイズを指定して 0 埋め構築します。","","後ろに要素を追架します。","特定のビットを立てます。","","","","","","","","","","","","","","","","","","","","","","","","","特定のビットが立っていれば <code>true</code> …","","","","","","","","","特定のビットをおろします。"],"i":[0,0,1,1,1,11,1,11,1,1,1,1,1,1,1,1,11,1,1,1,1,11,1,11,1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,11,1,11,1,11,1,1],"f":[0,0,[[1,1],2],[[1,1],2],[[1,1],2],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[[-1,-2],2,[],[]],[[],1],[[1,1],3],[[-1,-2],3,[],[]],[[1,4],5],[[1,6,6],7],[-1,-1,[]],[-1,-1,[]],[8,1],[-1,1,9],[[1,-1],2,10],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,11],[1,3],[1,11],[1,12],[12,1],[11,[[13,[3]]]],[[1,3],2],[[1,12],2],[[1,14],2],[[1,15],2],[[1,16],2],[[1,17],2],[[1,12],2],[[1,18],2],[[1,19],2],[[1,20],2],[[1,21],2],[[1,22],2],[[1,23],2],[[1,24],2],[[1,14],2],[[1,15],2],[[1,21],2],[[1,17],2],[[1,22],2],[[1,20],2],[[1,18],2],[[1,16],2],[[1,24],2],[[1,23],2],[[1,12],2],[[1,19],2],[[1,12],3],[-1,-2,[],[]],[1,7],[-1,[[25,[-2]]],[],[]],[-1,[[25,[-2]]],[],[]],[-1,[[25,[-2]]],[],[]],[-1,[[25,[-2]]],[],[]],[-1,26,[]],[-1,26,[]],[[1,12],2]],"c":[],"p":[[3,"BitVec",0],[15,"tuple"],[15,"bool"],[3,"Formatter",66],[6,"Result",66],[15,"char"],[3,"String",67],[15,"str"],[8,"IntoIterator",68],[8,"Hasher",69],[3,"Iter",0],[15,"usize"],[4,"Option",70],[15,"u32"],[15,"i64"],[15,"u128"],[15,"i16"],[15,"u16"],[15,"i128"],[15,"u64"],[15,"u8"],[15,"i8"],[15,"isize"],[15,"i32"],[4,"Result",71],[3,"TypeId",72]]},\
"bsgs":{"doc":"Baby-step giant-step …","t":"DLLLLLLLLLLLLL","n":["Bsgs","borrow","borrow_mut","clone","clone_into","fmt","from","into","log","new","to_owned","try_from","try_into","type_id"],"q":[[0,"bsgs"],[14,"core::clone"],[15,"core::fmt"],[16,"core::fmt"],[17,"core::marker"],[18,"core::hash"],[19,"core::cmp"],[20,"core::ops::function"],[21,"core::result"],[22,"core::any"]],"d":["Baby-stpp giant-step のソルバーです。","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","<code>x</code> …","新しい BSGS ソルバーを構築します。","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1,-2]]],[[1,[-1,-2]]],2,2],[[-1,-2],3,[],[]],[[[1,[-1,-2]],4],5,6,[]],[-1,-1,[]],[-1,-2,[],[]],[[[1,[-1,-2]],-1],[[8,[7]]],[9,10,11],12],[[-1,7,-2,-3,-4],[[1,[-1,-2]]],[9,10,11],12,12,12],[-1,-2,[],[]],[-1,[[13,[-2]]],[],[]],[-1,[[13,[-2]]],[],[]],[-1,14,[]]],"c":[],"p":[[3,"Bsgs",0],[8,"Clone",14],[15,"tuple"],[3,"Formatter",15],[6,"Result",15],[8,"Debug",15],[15,"u64"],[4,"Option",16],[8,"Copy",17],[8,"Hash",18],[8,"Eq",19],[8,"Fn",20],[4,"Result",21],[3,"TypeId",22]]},\
"cht":{"doc":"CHT です。","t":"DEEIDDRLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["BTreeCht","Concave","Convex","ConvexOrConcave","Quadratic","VecCht","X","add","add","add","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","default","default","default","eq","eq","eq","equivalent","equivalent","equivalent","eval","eval","eval","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","hash","hash","hash","hash","hash","into","into","into","into","into","mul","multieval","multieval","neg","negate_if_concave","negate_if_concave","negate_if_concave","new","new","square","sub","to_owned","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id"],"q":[[0,"cht"],[94,"core::convert"],[95,"core::clone"],[96,"core::default"],[97,"core::cmp"],[98,"core::fmt"],[99,"core::fmt"],[100,"core::hash"],[101,"core::iter::traits::iterator"],[102,"core::result"],[103,"core::any"]],"d":["ログがつく方","凹関数を管理する方であるというマーカー","凸関数を管理する方であるというマーカー","<code>BTreeCht</code>, <code>VecCht</code> …","二次式","ログがつかない方","変数","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,0,1,5,2,7,8,1,5,2,7,8,1,5,2,7,8,1,5,2,7,8,1,5,2,1,5,2,1,5,2,1,5,2,1,5,2,7,8,1,5,2,7,8,1,5,2,2,7,8,1,5,2,7,8,1,5,2,2,1,5,2,4,7,8,1,5,2,2,7,8,1,5,2,7,8,1,5,2,7,8,1,5,2,7,8,1,5,2],"f":[0,0,0,0,0,0,0,[[[1,[-1]],2],3,4],[[[5,[-1]],2],3,4],[[2,-1],[],[[6,[2]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[7,7],[8,8],[[[1,[-1]]],[[1,[-1]]],9],[[[5,[-1]]],[[5,[-1]]],9],[2,2],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[[],[[1,[-1]]],10],[[],[[5,[-1]]],10],[[],2],[[[1,[-1]],[1,[-1]]],11,12],[[[5,[-1]],[5,[-1]]],11,12],[[2,2],11],[[-1,-2],11,[],[]],[[-1,-2],11,[],[]],[[-1,-2],11,[],[]],[[[1,[-1]],13],13,4],[[[5,[-1]],13],13,4],[[2,13],13],[[7,14],15],[[8,14],15],[[[1,[-1]],14],15,16],[[[5,[-1]],14],15,16],[[2,14],15],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[13,2],[[7,-1],3,17],[[8,-1],3,17],[[[1,[-1]],-2],3,18,17],[[[5,[-1]],-2],3,18,17],[[2,-1],3,17],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[2,-1],[],[[6,[2]]]],[[[1,[-1]],-2],[[19,[13]]],4,20],[[[5,[-1]],-2],[[19,[13]]],4,20],[2],[13,13],[13,13],[13,13],[[],[[1,[-1]]],4],[[],[[5,[-1]]],4],[2,2],[[2,-1],[],[[6,[2]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,22,[]],[-1,22,[]],[-1,22,[]],[-1,22,[]],[-1,22,[]]],"c":[],"p":[[3,"VecCht",0],[3,"Quadratic",0],[15,"tuple"],[8,"ConvexOrConcave",0],[3,"BTreeCht",0],[8,"Into",94],[4,"Convex",0],[4,"Concave",0],[8,"Clone",95],[8,"Default",96],[15,"bool"],[8,"PartialEq",97],[15,"i64"],[3,"Formatter",98],[6,"Result",98],[8,"Debug",98],[8,"Hasher",99],[8,"Hash",99],[3,"Vec",100],[8,"Iterator",101],[4,"Result",102],[3,"TypeId",103]]},\
"cipolla":{"doc":"","t":"SSISF","n":["ONE","TWO","Unsigned","ZERO","cipolla_sqrt"],"q":[[0,"cipolla"],[5,"core::option"]],"d":["","","","",""],"i":[2,2,0,2,0],"f":[0,0,0,0,[[-1,-1],[[1,[-1]]],2]],"c":[],"p":[[4,"Option",5],[8,"Unsigned",0]]},\
"convex_hull":{"doc":"","t":"FFFFF","n":["caliper","ccw","convex_hull","is_convex","sqmag"],"q":[[0,"convex_hull"],[5,"alloc::vec"]],"d":["凸包を求めます。 …","det(p1 - p0, p2 - p0) を求めます。","凸包を求めます。 …","凸であれば true を返します。","|p0 - p1| ^ 2 を求めます。"],"i":[0,0,0,0,0],"f":[[[[3,[[2,[1]]]]],[[4,[1,[2,[[2,[1]]]]]]]],[[[2,[1]],[2,[1]],[2,[1]]],1],[[[3,[[2,[1]]]]],[[5,[[2,[1]]]]]],[[[3,[[2,[1]]]]],6],[[[2,[1]],[2,[1]]],1]],"c":[],"p":[[15,"i64"],[15,"array"],[15,"slice"],[15,"tuple"],[3,"Vec",5],[15,"bool"]]},\
"dinic":{"doc":"Solves maximum flow problem.","t":"DDDILLLLLLLMLLLLLLLLLLLLLMLLLLLLLMLLLLKLLLLLMLLLLLLLLLLLLK","n":["Dinic","Edge","EdgeKey","Value","add_edge","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","cap","change_edge","clone","clone","clone","clone_into","clone_into","clone_into","eq","eq","eq","equivalent","equivalent","flow","flow","flow_with_limit","fmt","fmt","fmt","from","from","from","from","get_edge","get_edges","get_excess","get_network","infinity","into","into","into","min_cut","new","to","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","zero"],"q":[[0,"dinic"],[58,"core::clone"],[59,"core::cmp"],[60,"core::fmt"],[61,"core::fmt"],[62,"core::result"],[63,"core::any"]],"d":["A struct to execute Dinic’s algorithm.","A summary of the state of an edge, which is returned by …","A key object to query an edge.","An adapter trait of the capacity.","Inserts a new edge to the network.","","","","","","","The capacity of an edge.","Changes the capacity and the amount of the edge …","","","","","","","","","","","","Auguments the flow from <code>s</code> to <code>t</code> as much as possible. It …","The value of the flow of the network at this edge.","Auguments the flow from <code>s</code> to <code>t</code> as much as possible as long …","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","The vertex-index of the source of an edge.","Returns the current internal state of the edges.","Collects all the edges.","Returens the <code>Vec</code> of excess of all the vertices.","Collects all the edges and arrange it in adjacent-list …","Returns the max value of <code>Self</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Returns a vector of length <code>n</code>, such that the <code>i</code>-th element …","Creates a new instance of <code>Dinic</code>","The vertex-index of the target of an edge.","","","","","","","","","","","","","Returns the zero."],"i":[0,0,0,0,1,1,7,3,1,7,3,7,1,1,7,3,1,7,3,1,7,3,7,3,1,7,1,1,7,3,1,7,3,7,1,1,1,1,4,1,7,3,1,1,7,1,7,3,1,7,3,1,7,3,1,7,3,4],"f":[0,0,0,0,[[[1,[-1]],2,2,-1],3,4],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],0,[[[1,[-1]],3,-1,-1],5,4],[[[1,[-1]]],[[1,[-1]]],6],[[[7,[-1]]],[[7,[-1]]],6],[3,3],[[-1,-2],5,[],[]],[[-1,-2],5,[],[]],[[-1,-2],5,[],[]],[[[1,[-1]],[1,[-1]]],8,9],[[[7,[-1]],[7,[-1]]],8,9],[[3,3],8],[[-1,-2],8,[],[]],[[-1,-2],8,[],[]],[[[1,[-1]],2,2],-1,4],0,[[[1,[-1]],2,2,-1],-1,4],[[[1,[-1]],10],11,4],[[[7,[-1]],10],11,12],[[3,10],11],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],0,[[[1,[-1]],3],[[7,[-1]]],4],[[[1,[-1]]],[[13,[[7,[-1]]]]],4],[[[1,[-1]]],[[13,[-1]]],4],[[[1,[-1]]],[[13,[[13,[[7,[-1]]]]]]],4],[[],-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]],2],[[13,[8]]],4],[2,[[1,[-1]]],4],0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,15,[]],[-1,15,[]],[-1,15,[]],[[],-1,[]]],"c":[],"p":[[3,"Dinic",0],[15,"usize"],[3,"EdgeKey",0],[8,"Value",0],[15,"tuple"],[8,"Clone",58],[3,"Edge",0],[15,"bool"],[8,"PartialEq",59],[3,"Formatter",60],[6,"Result",60],[8,"Debug",60],[3,"Vec",61],[4,"Result",62],[3,"TypeId",63]]},\
"dual_segtree":{"doc":"双対セグメント木（右作用）","t":"DIQLLLLLLLLLLLLLLLLKLLLLLKLLLLL","n":["DualSegtree","Ops","Value","apply","borrow","borrow_mut","clone","clone_into","collect_vec","default","eq","fmt","from","from","from_iter","get","get_cloned","get_copied","get_mut","identity","into","into_vec","is_empty","len","new","op","op_assign_from_right","to_owned","try_from","try_into","type_id"],"q":[[0,"dual_segtree"],[31,"core::ops::range"],[32,"core::clone"],[33,"alloc::vec"],[34,"core::default"],[35,"core::cmp"],[36,"core::fmt"],[37,"core::fmt"],[38,"core::result"],[39,"core::any"]],"d":["双対セグメント木（右作用）","演算（右作用）","値型","<code>range</code> に <code>x</code> を作用させます。（右作用）","","","","","<code>Vec</code> に変換します。","","","","","Returns the argument unchanged.","","<code>i</code> 番目の要素への参照を返します。","<code>i</code> 番目の要素をクローンして返します。","<code>i</code> 番目の要素をコピーして返します。","<code>i</code> 番目の要素への可変参照を返します。","<code>op</code> の単位元","Calls <code>U::from(self)</code>.","<code>Vec</code> に変換します。","空なら <code>true</code> を返します。","管理している配列の長さを返します。","<code>ExactSizeIterator</code> から作ります。","作用する演算（右作用）","<code>lhs</code> を <code>op(lhs, rhs)</code> で置き換えます。","","","",""],"i":[0,0,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,3,3,1,1,1,1],"f":[0,0,0,[[[1,[-1]],-2],2,3,[[5,[4]]]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],[6,3]],[[-1,-2],2,[],[]],[[[1,[-1]]],7,3],[[],[[1,[-1]]],[8,3]],[[[1,[-1]],[1,[-1]]],9,[10,3]],[[[1,[-1]],11],12,3],[7,[[1,[-1]]],3],[-1,-1,[]],[-1,[[1,[-2]]],13,3],[[[1,[-1]],4],[],3],[[[1,[-1]],4],[],3],[[[1,[-1]],4],[],3],[[[1,[-1]],4],[],3],[[]],[-1,-2,[],[]],[[[1,[-1]]],7,3],[[[1,[-1]]],9,3],[[[1,[-1]]],4,3],[-1,[[1,[-2]]],13,3],[[]],[[],2],[-1,-2,[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,15,[]]],"c":[],"p":[[3,"DualSegtree",0],[15,"tuple"],[8,"Ops",0],[15,"usize"],[8,"RangeBounds",31],[8,"Clone",32],[3,"Vec",33],[8,"Default",34],[15,"bool"],[8,"PartialEq",35],[3,"Formatter",36],[6,"Result",36],[8,"IntoIterator",37],[4,"Result",38],[3,"TypeId",39]]},\
"elim":{"doc":"","t":"F","n":["column_reduce"],"q":[[0,"elim"],[1,"alloc::vec"]],"d":["…"],"i":[0],"f":[[[[3,[[2,[1]]]]],4]],"c":[],"p":[[15,"bool"],[3,"Vec",1],[15,"slice"],[15,"usize"]]},\
"erato":{"doc":"Use the two types of sieve of eratosthenes to query.","t":"IDIDDDDDDKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLK","n":["Int","LpdSieve","PrimeFactors","PrimeFactorsByLookup","PrimeFactorsByTrialDivision","PrimeNumbers","Rle","Sieve","Unique","as_usize","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","default","default","eq","eq","fmt","fmt","from","from","from","from","from","from","from","from_usize","into","into","into","into","into","into","into","into_iter","into_iter","into_iter","into_iter","into_iter","is_empty","is_empty","is_prime","is_prime","len","len","lpd","new","new","next","next","next","next","next","one","prime_factors","prime_factors","prime_numbers","prime_numbers","rle","rle","rle","rle","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","two","type_id","type_id","type_id","type_id","type_id","type_id","type_id","unique","unique","unique","unique","with_len","with_len","zero"],"q":[[0,"erato"],[108,"core::fmt"],[109,"core::fmt"],[110,"core::result"],[111,"core::any"]],"d":["Abstraction of integers.","Least-prime-divisor table.","An abstraction of prime factor generator.","See the document of <code>crate::LpdSieve::prime_factors</code>","See the document of <code>crate::Sieve::prime_factors</code>","An iterator to generate all the prime numbers, constructed …","An iterator returned by <code>PrimeFactors::rle</code>","Is-prime table.","An iterator returned by <code>PrimeFactors::unique</code>","Converts into <code>usize</code>","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Converts an <code>usize</code> into <code>Self</code>","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","Returns <code>true</code> if a sieve is empty.","Returns <code>true</code> if a sieve is empty.","Returns <code>true</code> if <code>x</code> is a prime number.","Returns <code>true</code> if <code>x</code> is a prime number.","Returns the length of a sieve.","Returns the length of a sieve.","Returns the least prime divisor of <code>x</code>.","Construct a new empty sieve. No heap allocations is run …","Construct a new empty sieve. No heap allocations is run …","","","","","","Returns <code>1</code>.","Use trial-division algorithm to iterate over all the prime …","Use trial-division algorithm to iterate over all the prime …","Returns an iterator to generate all the prime numbers in …","Returns an iterator to generate all the prime numbers in …","Returns an iterator to generate the pairs of distinct …","Returns an iterator to generate the pairs of distinct …","","Forward <code>crate::PrimeFactors::rle</code>.","","","","","","","","","","","","","","","","","Returns <code>2</code>.","","","","","","","","Make prime factors unique.","Make prime factors unique.","","Forward <code>crate::PrimeFactors::unique</code>.","Construct a sieve of given length.","Construct a sieve of given length.","Returns <code>0</code>."],"i":[0,0,0,0,0,0,0,0,0,8,9,12,13,14,15,2,3,9,12,13,14,15,2,3,2,3,2,3,2,3,2,3,2,3,9,12,13,14,15,2,3,8,9,12,13,14,15,2,3,9,12,13,14,15,2,3,2,3,2,3,2,2,3,9,12,13,14,15,8,2,3,2,3,11,11,14,15,2,3,9,12,13,14,15,2,3,9,12,13,14,15,2,3,8,9,12,13,14,15,2,3,11,11,14,15,2,3,8],"f":[0,0,0,0,0,0,0,0,0,[-1,1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[2,2],[3,3],[[-1,-2],4,[],[]],[[-1,-2],4,[],[]],[[],2],[[],3],[[2,2],5],[[3,3],5],[[2,6],7],[[3,6],7],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[2,5],[3,5],[[2,-1],5,8],[[3,-1],5,8],[2,1],[3,1],[[2,-1],-1,8],[[],2],[[],3],[[[9,[-1,-2]]],10,8,[[11,[-1]]]],[[[12,[-1,-2]]],10,8,[[11,[-1]]]],[[[13,[-1,-2]]],10,0,8],[[[14,[-1]]],10,8],[[[15,[-1]]],10,8],[[],-1,[]],[[2,-1],[[15,[-1]]],8],[[3,-1],[[14,[-1]]],8],[2,[[13,[0,-1]]],8],[3,[[13,[0,-1]]],8],[-1,[[12,[-2,-1]]],[],[]],[-1,[[12,[-2,-1]]],[],[]],[[[14,[-1]]],[[12,[-1,[14,[-1]]]]],8],[[[15,[-1]]],[[12,[-1,[15,[-1]]]]],8],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[[],-1,[]],[-1,17,[]],[-1,17,[]],[-1,17,[]],[-1,17,[]],[-1,17,[]],[-1,17,[]],[-1,17,[]],[-1,[[9,[-2,-1]]],[],[]],[-1,[[9,[-2,-1]]],[],[]],[[[14,[-1]]],[[9,[-1,[14,[-1]]]]],8],[[[15,[-1]]],[[9,[-1,[15,[-1]]]]],8],[1,2],[1,3],[[],-1,[]]],"c":[],"p":[[15,"usize"],[3,"LpdSieve",0],[3,"Sieve",0],[15,"tuple"],[15,"bool"],[3,"Formatter",108],[6,"Result",108],[8,"Int",0],[3,"Unique",0],[4,"Option",109],[8,"PrimeFactors",0],[3,"Rle",0],[3,"PrimeNumbers",0],[3,"PrimeFactorsByTrialDivision",0],[3,"PrimeFactorsByLookup",0],[4,"Result",110],[3,"TypeId",111]]},\
"euclid":{"doc":"","t":"IIIKFKLFFKKKK","n":["Int","Signed","Unsigned","abs","crt","div_euclid","divides","ext_gcd","gcd","increment","one","rem_euclid","zero"],"q":[[0,"euclid"],[13,"core::option"]],"d":["Abstraction of integers.","Abstraction of signed integers.","Abstraction of unsigned integers.","Returns the absolute value.","Returns an integer <code>res2, mod2</code> such that (res0 + mod0 ℤ) …","Calculates the quotient of Euclidean division of self by …","Returns <code>true</code> if and only if <code>self</code> divides <code>n</code>.","Takes two integers <code>x, y</code> and returns <code>a, b, g</code> satisfying …","Returns the greatest common divisor of <code>x</code> and <code>y</code>.","Increment <code>self</code>.","Returns <code>1</code>.","Calculates the least nonnegative remainder of …","Returns <code>0</code>."],"i":[0,0,0,5,0,5,5,0,0,5,5,5,5],"f":[0,0,0,[-1,-1,[]],[[-1,-1,-1,-1],[[2,[[1,[-1,-1]]]]],3],[[-1,-1],-1,[]],[[-1,-1],4,[]],[[-1,-1],[[1,[-1,-1,-1]]],3],[[-1,-1],-1,5],[-1,1,[]],[[],-1,[]],[[-1,-1],-1,[]],[[],-1,[]]],"c":[],"p":[[15,"tuple"],[4,"Option",13],[8,"Signed",0],[15,"bool"],[8,"Int",0]]},\
"fp":{"doc":"A library for modular arithmetic.","t":"DDISDLLLLLLFLLLLLLLLLLLLLLLLLLLLLLLFLLLOFLLLLLLLLLLLLLLLLFLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["Factorial","Fp","PrimitiveRoot","VALUE","Zeroed","add","add","add","add","add_assign","add_assign","any_mod_fps_mul","binom","binom_signed","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","div","div","div","div","div_assign","div_assign","div_assign","eq","equivalent","fact","falling","fft","fmt","fmt","fmt","fp","fps_mul","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","hash","ifft","index","into","into","into","inv","inv_fact","m1pow","mul","mul","mul","mul","mul_assign","mul_assign","mul_assign","multinom","multiset_number","neg","new","new","new","one","pow","product","product","sign","sub","sub","sub","sub","sub_assign","sub_assign","sum","sum","to_owned","to_owned","to_string","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","value","value"],"q":[[0,"fp"],[105,"core::convert"],[106,"alloc::vec"],[107,"core::fmt"],[108,"core::fmt"],[109,"core::iter::traits::iterator"],[110,"alloc::string"],[111,"core::result"],[112,"core::any"]],"d":["Precomputes the factorials and their inverses.","A value in $\\\\mathbb{Fp}_p$.","A primitive root of unity.","A primitive root of unity.","Represents a $p$-adic leading term $a \\\\cdot p^e$ ($a \\\\in …","","","","","","","Multiplies two polynomials.","$[x^k](1 + x)^n$.","$[x^k](1 + x)^n$.","","","","","","","","","","","","","","","","","","","","The factorial $n!$ <code>Index</code> is implemented for this method.","$[x^{n-k}]D^k x^n$.","Fast Fourier transform.","","","","Constructs a new instance of <code>Fp</code>","Multiplies two polynomials.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","","","","","","","","Inverse fast Fourier transform.","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Returns the multiplicative inverse.","The inverse of the factorial $n!$","$(-1) ^ e$.","","","","","","","","$[x^{a_1} \\\\cdot x^{a_l}](x_{a_1} + \\\\cdot x_{a_l})^n$.","$[x^k](1 - x)^{-n}$.","","Constructs a new instance.","Projects the value $a \\\\cdot p^e$.","Constructs a new instance.","Returns $1 \\\\cdot p^0$.","Returns the $n$-th power.","","","Returns $(-1)^{\\\\text{pow}}$.","","","","","","","","","","","","","","","","","","","","","Returns the value projected to $\\\\mathbb{F} _ P$.","Returns the value."],"i":[0,0,0,29,0,1,1,1,1,1,1,0,6,6,6,9,1,6,9,1,9,1,9,1,1,1,1,1,9,1,1,1,1,6,6,0,9,1,1,0,0,6,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,6,6,9,1,1,6,1,1,1,1,1,9,1,1,6,6,1,6,9,1,9,1,1,1,1,1,1,1,1,1,1,1,1,9,1,1,6,9,1,6,9,1,6,9,1,9,1],"f":[0,0,0,0,0,[[1,-1],[],[[2,[1]]]],[[1,1]],[[1,1]],[[1,-1],[],[[2,[1]]]],[[1,1],3],[[1,1],3],[[[4,[1]],[4,[1]]],[[5,[1]]]],[[6,7,7],1],[[6,7,8],1],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[9,9],[1,1],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[[1,-1],[],[[2,[1]]]],[[1,1]],[[1,-1],[],[[2,[1]]]],[[1,1]],[[9,10],3],[[1,1],3],[[1,1],3],[[1,1],11],[[-1,-2],11,[],[]],[[6,7],1],[[6,7,7],1],[[[4,[1]]],3],[[9,12],13],[[1,12],13],[[1,12],13],0,[[-1,-2],[[5,[1]]],[[14,[[4,[1]]]]],[[14,[[4,[1]]]]]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[8,1],[10,1],[15,1],[7,1],[16,1],[17,1],[18,1],[19,1],[20,1],[21,1],[22,1],[23,1],[[1,-1],3,24],[[[4,[1]]],3],[[6,7]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[[6,7],1],[7,1],[[1,-1],[],[[2,[1]]]],[[1,-1],[],[[2,[1]]]],[[1,1]],[[1,1]],[[9,10],3],[[1,1],3],[[1,1],3],[[6,[4,[7]]],1],[[6,7,7],1],[1],[7,6],[10,9],[10,1],[[],9],[[1,10],1],[-1,1,25],[-1,1,25],[7,1],[[1,1]],[[1,-1],[],[[2,[1]]]],[[1,-1],[],[[2,[1]]]],[[1,1]],[[1,1],3],[[1,1],3],[-1,1,25],[-1,1,25],[-1,-2,[],[]],[-1,-2,[],[]],[-1,26,[]],[-1,[[27,[-2]]],[],[]],[-1,[[27,[-2]]],[],[]],[-1,[[27,[-2]]],[],[]],[-1,[[27,[-2]]],[],[]],[-1,[[27,[-2]]],[],[]],[-1,[[27,[-2]]],[],[]],[-1,28,[]],[-1,28,[]],[-1,28,[]],[9,1],[1,10]],"c":[],"p":[[3,"Fp",0],[8,"Into",105],[15,"tuple"],[15,"slice"],[3,"Vec",106],[3,"Factorial",0],[15,"usize"],[15,"isize"],[3,"Zeroed",0],[15,"u64"],[15,"bool"],[3,"Formatter",107],[6,"Result",107],[8,"AsRef",105],[15,"i32"],[15,"i8"],[15,"i64"],[15,"i16"],[15,"u128"],[15,"u32"],[15,"u8"],[15,"i128"],[15,"u16"],[8,"Hasher",108],[8,"Iterator",109],[3,"String",110],[4,"Result",111],[3,"TypeId",112],[8,"PrimitiveRoot",0]]},\
"fps":{"doc":"Arithmetic of formal power series.","t":"OFFFFFFF","n":["fps","fps_deriv","fps_exp","fps_int","fps_inv","fps_log","fps_pow","fps_sqrt"],"q":[[0,"fps"],[8,"fp"],[9,"alloc::vec"],[10,"core::convert"]],"d":["Define a formal power series in the same way as <code>vec!</code>.","Returns the derivative of a formal power series.","Returns the exponential of a formal power series.","Returns the integral of a formal power series with zero …","Returns the multiplicative inverse of a formal power …","Returns the logarithm of a formal power series.","Resutns the $n$-th power of a formal power series.","Returns the square root of a formal power series."],"i":[0,0,0,0,0,0,0,0],"f":[0,[[-1,1],[[3,[2]]],[[5,[[4,[2]]]]]],[[-1,1],[[3,[2]]],[[5,[[4,[2]]]]]],[[-1,1],[[3,[2]]],[[5,[[4,[2]]]]]],[[-1,1],[[3,[2]]],[[5,[[4,[2]]]]]],[[-1,1],[[3,[2]]],[[5,[[4,[2]]]]]],[[-1,1,1],[[3,[2]]],[[5,[[4,[2]]]]]],[[-1,1],[[3,[2]]],[[5,[[4,[2]]]]]]],"c":[],"p":[[15,"usize"],[3,"Fp",8],[3,"Vec",9],[15,"slice"],[8,"AsRef",10]]},\
"gco":{"doc":"Solve a submodular graph cut optimizaion problem of degree …","t":"DDMLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLM","n":["Gco","GcoResult","args","binary","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","default","default","eq","eq","equivalent","fmt","fmt","from","from","hash","hash","into","into","new","solve","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","unary","value"],"q":[[0,"gco"],[37,"core::fmt"],[38,"core::fmt"],[39,"core::result"],[40,"core::any"]],"d":["A solver of graph cut optimization problems.","The minimum value and and an argmin of $f$.","An argmin","Add a binary term.","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Initialize a solver with $n$ terms.","Returns the minimum value and an argmin of $f$.","","","","","","","","","Add a unary term.","The minimum value"],"i":[0,0,6,1,1,6,1,6,1,6,1,6,1,6,1,6,6,1,6,1,6,1,6,1,6,1,1,1,6,1,6,1,6,1,6,1,6],"f":[0,0,0,[[1,[3,[2]],[3,[[3,[4]]]]],5],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[6,6],[[-1,-2],5,[],[]],[[-1,-2],5,[],[]],[[],1],[[],6],[[1,1],7],[[6,6],7],[[-1,-2],7,[],[]],[[1,8],9],[[6,8],9],[-1,-1,[]],[-1,-1,[]],[[1,-1],5,10],[[6,-1],5,10],[-1,-2,[],[]],[-1,-2,[],[]],[2,1],[1,6],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,12,[]],[-1,12,[]],[[1,2,[3,[4]]],5],0],"c":[],"p":[[3,"Gco",0],[15,"usize"],[15,"array"],[15,"i64"],[15,"tuple"],[3,"GcoResult",0],[15,"bool"],[3,"Formatter",37],[6,"Result",37],[8,"Hasher",38],[4,"Result",39],[3,"TypeId",40]]},\
"graph":{"doc":"Kosaraju’s algorithm for strongly connected components","t":"DDDLLLLLLMMLLLLLLLLLLLLLLLLLLLLLLLFLLLLLLLLLLLLLLLLLLLLLL","n":["Csr","Iter","LastMut","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","boundary","data","default","deref","deref_mut","extend","extend_from_slice","flat_len","fmt","from","from","from","from_edges","from_edges_and_rev","from_iter","from_sections","index","index_mut","into","into","into","into_iter","into_iter","is_empty","iter","kosaraju","last_mut","len","len","new","next","next_back","push","push_empty","push_section","section","section_mut","to_vec","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","with_capacity"],"q":[[0,"graph"],[57,"core::iter::traits::collect"],[58,"core::clone"],[59,"core::fmt"],[60,"core::fmt"],[61,"core::option"],[62,"alloc::vec"],[63,"core::result"],[64,"core::any"]],"d":["Compressed Sparse Row format","Immutable iterator over rows.","Mutable and extendable reference to the last section.","","","","","","","$S = [s_0, s_1, \\\\dots, s_{m}]$","$X = [x_0, x_1, \\\\dots, x_{n-1}]$","","","","Extend the last section with an iterator.","Copy elements from a slice to the last section.","Get the total number of elements in $A$. (i.e. $\\\\sum_…","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Create a CSR from a list of edges.","Create CSRs of $G$ and $G^{\\\\mathrm{op}}$ from a list of …","","Create a CSR from a list of sections.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","Check if the CSR is empty. (i.e. $A = [\\\\ ]$)","Return an iterator over the sections.","Returns the strongly connected components of a directed …","Get the mutable and extendable reference to the last …","Get the number of sections $m = |A|$.","","Create a CSR corrsponding to $A = [\\\\ ]$.","","","Push an element to the last section.","Push an empty section $A_m = [\\\\ ]$.","Clone and push a section.","Get the $i$-th section $A_i$. Alias for <code>&amp;self[i]</code>.","Get the mutable $i$-th section $A_i$. Alias for …","Copies <code>self</code> into a new <code>Vec&lt;Vec&lt;T&gt;&gt;</code>.","","","","","","","","","","Create a CSR corrsponding to $A = [\\\\ ]$ with preallocated …"],"i":[0,0,0,1,2,13,1,2,13,1,1,1,2,2,2,2,1,1,1,2,13,1,1,1,1,1,1,1,2,13,1,13,1,1,0,1,1,13,1,13,13,2,1,1,1,1,1,1,2,13,1,2,13,1,2,13,1],"f":[0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],0,0,[[],[[1,[-1]]],[]],[[[2,[-1]]],[],[]],[[[2,[-1]]],[],[]],[[[2,[-1]],-2],3,[],4],[[[2,[-1]],[5,[-1]]],3,6],[[[1,[-1]]],7,[]],[[[1,[-1]],8],9,10],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[[7,[5,[[3,[7,7]]]]],[[1,[7]]]],[[7,[5,[[3,[7,7]]]]],[[3,[[1,[7]],[1,[7]]]]]],[-1,[[1,[-2]]],4,[]],[[[5,[-2]]],[[1,[-1]]],6,[[11,[[5,[-1]]]]]],[[[1,[-1]],7],[[5,[-1]]],[]],[[[1,[-1]],7],[[5,[-1]]],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[],[]],[-1,-2,[],[]],[[[1,[-1]]],12,[]],[[[1,[-1]]],[[13,[-1]]],[]],[[7,[5,[[3,[7,7]]]]],[[1,[7]]]],[[[1,[-1]]],[[2,[-1]]],[]],[[[1,[-1]]],7,[]],[[[13,[-1]]],7,[]],[[],[[1,[-1]]],[]],[[[13,[-1]]],14,[]],[[[13,[-1]]],14,[]],[[[2,[-1]],-1],3,[]],[[[1,[-1]]],3,[]],[[[1,[-1]],[5,[-1]]],3,6],[[[1,[-1]],7],[[5,[-1]]],[]],[[[1,[-1]],7],[[5,[-1]]],[]],[[[1,[-1]]],[[15,[[15,[-1]]]]],6],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,17,[]],[-1,17,[]],[-1,17,[]],[[7,7],[[1,[-1]]],[]]],"c":[],"p":[[3,"Csr",0],[3,"LastMut",0],[15,"tuple"],[8,"IntoIterator",57],[15,"slice"],[8,"Clone",58],[15,"usize"],[3,"Formatter",59],[6,"Result",59],[8,"Debug",59],[8,"AsRef",60],[15,"bool"],[3,"Iter",0],[4,"Option",61],[3,"Vec",62],[4,"Result",63],[3,"TypeId",64]]},\
"gss":{"doc":"黄金分割探索をします。","t":"IISIKKKKFFFFKKKKKK","n":["Float","Golden","INVPHI","Int","abs","as_f64","f64_as","golden_sect","gss_by_absolute_eps","gss_by_count","gss_integer","gss_on_slice","is_finite","max","midpoint_sorted","one","two","zero"],"q":[[0,"gss"],[18,"core::ops::function"],[19,"core::cmp"],[20,"core::fmt"]],"d":["<code>gss_by_count</code> …","黄金分割をする関数 <code>golden_sect</code> …","1 / φ = 0.6180339887498949","<code>gss_integer</code> …","<code>Self</code> の同名メソッド","","","<code>self</code> と <code>other</code> を φ:1 …","…","回数指定バージョン。<code>count</code> …","整数バージョン。正確な値を返します。","…","<code>Self</code> の同名メソッド","<code>Self</code> の同名メソッド","数学的な <code>floor((self + upper)/2)</code> …","<code>1</code>","2.0","0.0"],"i":[0,0,2,0,2,6,6,3,0,0,0,0,2,2,6,6,2,2],"f":[0,0,0,0,[-1,-1,[]],[-1,1,[]],[1,-1,[]],[[-1,-1],-1,[]],[[-1,-1,-2,-1],-1,[2,3],4],[[-1,-1,-2,5],-1,[2,3],4],[[-1,-1,-2],-1,[6,3],4],[[[7,[-1]]],5,[8,9]],[-1,10,[]],[[-1,-1],-1,[]],[[-1,-1],-1,[]],[[],-1,[]],[[],-1,[]],[[],-1,[]]],"c":[],"p":[[15,"f64"],[8,"Float",0],[8,"Golden",0],[8,"Fn",18],[15,"usize"],[8,"Int",0],[15,"slice"],[8,"PartialOrd",19],[8,"Debug",20],[15,"bool"]]},\
"heap_slope_trick":{"doc":"<code>BinaryHeap</code> 二本で slope trick をします。","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLFLLLLLLLLLLLL","n":["HeapSlopeTrick","Summary","add_abs","add_const","add_cutoff_anti_diagonal","add_cutoff_diagonal","articulation_points","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","cumulative_min_from_left","cumulative_min_from_right","default","default","eq","equivalent","eval","fmt","fmt","from","from","get_argmin","get_minimum","get_tilt_maximum","get_tilt_minimum","hash","into","into","merge","new","shift","sliding_window_minimum","summary","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"heap_slope_trick"],[46,"alloc::vec"],[47,"core::fmt"],[48,"core::fmt"],[49,"core::result"],[50,"core::any"]],"d":["本体です。","<code>HeapSlopeTrick::summary()</code> の戻り値です。","絶対値関数加算 g(x) = f(x) + |x - a|","定数関数加算 g(x) = f(x) + c","傾き -1 のカットオフ一次関数加算 g(x) = f(x) …","傾き +1 のカットオフ一次関数加算 g(x) = f(x) …","関節点（二階差分が正である点）全体の列 …","","","","","","","","","左から累積最小値 g(x) = min { f(y) | y ∈ ]-∞, x…","右から累積最小値 g(x) = min { f(y) | y ∈ [x, ∞[…","","","","","一点評価 f(x)","","","Returns the argument unchanged.","Returns the argument unchanged.","最小値を取る x の集合（と [MIN, MAX] …","最小値取得 min { f(x) | x in ]-∞, ∞[ }","差分の最大値 max { f(x + 1) - f(x) | x ∈ ]-∞, ∞…","差分の最小値 min { f(x + 1) - f(x) | x ∈ ]-∞, ∞…","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","足し算をします。","零関数 f(x) = 0","平行移動 g(x) = f ( x - a )","スライド最小値 g(x) = min { f(y) |  y ∈ [x - b, x …","関節点と差分の範囲を返します。","","","","","","","",""],"i":[0,0,1,1,1,1,1,1,6,1,6,1,6,1,6,1,1,1,6,6,6,1,1,6,1,6,1,1,1,1,6,1,6,0,1,1,1,1,1,6,1,6,1,6,1,6],"f":[0,0,[[1,2],3],[[1,2],3],[[1,2],3],[[1,2],3],[1,[[5,[[4,[2]]]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[6,6],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[1,3],[1,3],[[],1],[[],6],[[6,6],7],[[-1,-2],7,[],[]],[[1,2],2],[[1,8],9],[[6,8],9],[-1,-1,[]],[-1,-1,[]],[1,[[4,[2]]]],[1,2],[1,2],[1,2],[[6,-1],3,10],[-1,-2,[],[]],[-1,-2,[],[]],[[1,1],1],[[],1],[[1,2],3],[[1,2,2],3],[1,6],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,12,[]],[-1,12,[]]],"c":[],"p":[[3,"HeapSlopeTrick",0],[15,"i64"],[15,"tuple"],[15,"array"],[3,"Vec",46],[3,"Summary",0],[15,"bool"],[3,"Formatter",47],[6,"Result",47],[8,"Hasher",48],[4,"Result",49],[3,"TypeId",50]]},\
"heap_tricks":{"doc":"<code>remove_unchecked</code> のできるヒープです。","t":"DIDDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLMLLLLLLLLLLLKLLLKLLLLKLLLKLLLLLLMLLLLLLLLLLLLLLLLLL","n":["DoubleHeap","Handler","Nop","RemovableHeap","Sum","balance_left","balance_right","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","collect_left_sorted_vec","collect_right_sorted_vec","collect_sorted_vec","collect_sorted_vec","default","default","default","default","eq","eq","equivalent","equivalent","fmt","fmt","fmt","fmt","from","from","from","from","from_iter","handler","hash","hash","into","into","into","into","is_empty","is_empty","left","left_len","len","len","move_left","move_right","new","new","peek","peek_left","peek_right","pop","pop_left","pop_left","pop_left","pop_left","pop_right","pop_right","pop_right","pop_right","push","push_left","push_left","push_left","push_left","push_right","push_right","push_right","push_right","remove_left_unchecked","remove_right_unchecked","remove_unchecked","right","right_len","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","with_handler"],"q":[[0,"heap_tricks"],[104,"core::marker"],[105,"core::cmp"],[106,"core::hash"],[107,"core::clone"],[108,"alloc::vec"],[109,"core::default"],[110,"core::cmp"],[111,"core::fmt"],[112,"core::hash"],[113,"core::result"],[114,"core::any"]],"d":["…","集約操作を指定するためのトレイトです。 …","何も集約しないことを表す型です。 <code>Handler</code> …","論理削除のできるヒープです。","総和を集約するための型です。 <code>Handler</code> …","左側ヒープの要素が <code>k</code> …","右側ヒープの要素が <code>k</code> …","","","","","","","","","","","","","","","","","…","…","…","…","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","ハンドラへの参照を返します。","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","ヒープが空ならば <code>true</code> を返します。","ヒープが空ならば <code>true</code> を返します。","","左側ヒープの要素数を返します。","全体の要素数を返します。","ヒープの長さを返します。","…","…","","空のヒープを構築します。","…","左側ヒープの最大要素があれば返します。","右側ヒープの最大要素があれば返します。","…","左側から削除するときのコールバック関数","","","…","右側から削除するときのコールバック関数","","","…","ヒープに新しい要素 <code>x</code> を追加します。","左側に挿入するときのコールバック関数","","","…","右側に挿入するときのコールバック関数","","","…","…","…","ヒープに含まれる要素 <code>x</code> を削除します。 …","","右側ヒープの要素数を返します。","","","","","","","","","","","","","","","","","<code>Handler</code> を指定して構築します。"],"i":[0,0,0,0,0,1,1,8,9,1,11,8,9,1,11,8,9,1,11,8,9,1,11,1,1,1,11,8,9,1,11,8,9,8,9,8,9,1,11,8,9,1,11,11,1,8,9,8,9,1,11,1,11,9,1,1,11,1,1,1,11,11,1,1,11,7,8,9,1,7,8,9,1,11,7,8,9,1,7,8,9,1,1,1,11,9,1,8,9,1,11,8,9,1,11,8,9,1,11,8,9,1,11,1],"f":[0,0,0,0,0,[[[1,[-1,-2]],2],3,[4,5,6],[[7,[-1]]]],[[[1,[-1,-2]],2],3,[4,5,6],[[7,[-1]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[8,8],[[[9,[-1]]],[[9,[-1]]],10],[[[1,[-1,-2]]],[[1,[-1,-2]]],10,10],[[[11,[-1]]],[[11,[-1]]],10],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[[-1,-2],3,[],[]],[[[1,[-1,-2]]],[[12,[-1]]],[4,5,6],[[7,[-1]]]],[[[1,[-1,-2]]],[[12,[-1]]],[4,5,6],[[7,[-1]]]],[[[1,[-1,-2]]],[[12,[-1]]],[4,5,6],[[7,[-1]]]],[[[11,[-1]]],[[12,[-1]]],[4,5,6]],[[],8],[[],[[9,[-1]]],13],[[],[[1,[-1,8]]],[4,5,6]],[[],[[11,[-1]]],[4,5,6]],[[8,8],14],[[[9,[-1]],[9,[-1]]],14,15],[[-1,-2],14,[],[]],[[-1,-2],14,[],[]],[[8,16],17],[[[9,[-1]],16],17,18],[[[1,[-1,-2]],16],17,[4,5,6,18],[[7,[-1]],18]],[[[11,[-1]],16],17,[4,5,6,18]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,[[11,[-2]]],19,[4,5,6]],[[[1,[-1,-2]]],-2,[4,5,6],[[7,[-1]]]],[[8,-1],3,20],[[[9,[-1]],-2],3,6,20],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1,-2]]],14,[4,5,6],[[7,[-1]]]],[[[11,[-1]]],14,[4,5,6]],0,[[[1,[-1,-2]]],2,[4,5,6],[[7,[-1]]]],[[[1,[-1,-2]]],2,[4,5,6],[[7,[-1]]]],[[[11,[-1]]],2,[4,5,6]],[[[1,[-1,-2]]],3,[4,5,6],[[7,[-1]]]],[[[1,[-1,-2]]],3,[4,5,6],[[7,[-1]]]],[[],[[1,[-1,8]]],[4,5,6]],[[],[[11,[-1]]],[4,5,6]],[[[11,[-1]]],[[21,[-1]]],[4,5,6]],[[[1,[-1,-2]]],[[21,[-1]]],[4,5,6],[[7,[-1]]]],[[[1,[-1,-2]]],[[21,[-1]]],[4,5,6],[[7,[-1]]]],[[[11,[-1]]],[[21,[-1]]],[4,5,6]],[[-1,-2],3,[],[]],[[8,-1],3,[]],[[[9,[-1]],-1],3,[]],[[[1,[-1,-2]]],[[21,[-1]]],[4,5,6],[[7,[-1]]]],[[-1,-2],3,[],[]],[[8,-1],3,[]],[[[9,[-1]],-1],3,[]],[[[1,[-1,-2]]],[[21,[-1]]],[4,5,6],[[7,[-1]]]],[[[11,[-1]],-1],3,[4,5,6]],[[-1,-2],3,[],[]],[[8,-1],3,[]],[[[9,[-1]],-1],3,[]],[[[1,[-1,-2]],-1],3,[4,5,6],[[7,[-1]]]],[[-1,-2],3,[],[]],[[8,-1],3,[]],[[[9,[-1]],-1],3,[]],[[[1,[-1,-2]],-1],3,[4,5,6],[[7,[-1]]]],[[[1,[-1,-2]],-1],3,[4,5,6],[[7,[-1]]]],[[[1,[-1,-2]],-1],3,[4,5,6],[[7,[-1]]]],[[[11,[-1]],-1],3,[4,5,6]],0,[[[1,[-1,-2]]],2,[4,5,6],[[7,[-1]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[22,[-2]]],[],[]],[-1,[[22,[-2]]],[],[]],[-1,[[22,[-2]]],[],[]],[-1,[[22,[-2]]],[],[]],[-1,[[22,[-2]]],[],[]],[-1,[[22,[-2]]],[],[]],[-1,[[22,[-2]]],[],[]],[-1,[[22,[-2]]],[],[]],[-1,23,[]],[-1,23,[]],[-1,23,[]],[-1,23,[]],[-2,[[1,[-1,-2]]],[4,5,6],[[7,[-1]]]]],"c":[],"p":[[3,"DoubleHeap",0],[15,"usize"],[15,"tuple"],[8,"Copy",104],[8,"Ord",105],[8,"Hash",106],[8,"Handler",0],[3,"Nop",0],[3,"Sum",0],[8,"Clone",107],[3,"RemovableHeap",0],[3,"Vec",108],[8,"Default",109],[15,"bool"],[8,"PartialEq",105],[3,"Formatter",110],[6,"Result",110],[8,"Debug",110],[8,"IntoIterator",111],[8,"Hasher",106],[4,"Option",112],[4,"Result",113],[3,"TypeId",114]]},\
"hld":{"doc":"Heavy-Light Decomposition","t":"DDLLLLLLLLLLLMMLLLLLLMLLLLLLLL","n":["Hld","PathSegments","between","borrow","borrow","borrow_mut","borrow_mut","dist","from","from","from_edge_iterator","from_edges","from_short_parents","head","index","into","into","into_iter","lca","ledacy_iter_v","next","parent","path_segments","path_segments_by_index","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"hld"],[30,"alloc::vec"],[31,"core::iter::traits::exact_size"],[32,"core::iter::traits::iterator"],[33,"core::option"],[34,"core::result"],[35,"core::any"]],"d":["Heavy-Light Decomposition","Iterator","<code>j</code> lies between <code>i</code> and <code>k</code>","","","","","Returns the distance between two vertices","Returns the argument unchanged.","Returns the argument unchanged.","Iterator version of <code>from_edges</code>","From the set of undirected edges $(u _ 0, v _ 0), \\\\dots ( …","From $p _ 1, \\\\dots, p _ { n - 1 }$. Root is always $0$.","vertex id -&gt; head vertex id","vertex id -&gt; vertex index (in the hld order)","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","Returns the lca","deprecated","","vertex id -&gt; parent vertex id","Decompose the (directed) path <code>from --&gt; to</code> to the path …","Variation of <code>path_segments</code> that returns the <code>index</code>.","","","","","",""],"i":[0,0,1,1,9,1,9,1,1,9,1,1,1,1,1,1,9,9,1,1,9,1,1,1,1,9,1,9,1,9],"f":[0,0,[[1,2,2,2],3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[1,2,2],2],[-1,-1,[]],[-1,-1,[]],[[2,-1],[[5,[1,[4,[[4,[2]]]]]]],6],[[2,[7,[[5,[2,2]]]]],[[5,[1,[4,[[4,[2]]]]]]]],[[[4,[2]]],[[5,[1,[4,[[4,[2]]]]]]]],0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[1,2,2],2],[[1,2,2],[[0,[8]]]],[9,10],0,[[1,2,2],9],[[1,2,2],[[0,[8]]]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,12,[]],[-1,12,[]]],"c":[],"p":[[3,"Hld",0],[15,"usize"],[15,"bool"],[3,"Vec",30],[15,"tuple"],[8,"ExactSizeIterator",31],[15,"slice"],[8,"Iterator",32],[3,"PathSegments",0],[4,"Option",33],[4,"Result",34],[3,"TypeId",35]]},\
"hopkarp":{"doc":"Finds a maximum cardinality bipartite matching by …","t":"DMLLLLMLLLLMLLFLMMLLLL","n":["HopkarpResult","backward","borrow","borrow_mut","clone","clone_into","count","default","eq","equivalent","fmt","forward","from","hash","hopkarp","into","left","right","to_owned","try_from","try_into","type_id"],"q":[[0,"hopkarp"],[22,"core::fmt"],[23,"core::fmt"],[24,"alloc::vec"],[25,"core::result"],[26,"core::any"]],"d":["Summary of the result of Hopcroft―Karp’s algorithm.","","","","","","Cardinality of a maximum cardinality bipartite matching.","","","","","","Returns the argument unchanged.","","Takes a <em>forward</em> adjacency list and the length of the right …","Calls <code>U::from(self)</code>.","","","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1],"f":[0,0,[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[[-1,-2],2,[],[]],0,[[],1],[[1,1],3],[[-1,-2],3,[],[]],[[1,4],5],0,[-1,-1,[]],[[1,-1],2,6],[[7,[9,[[8,[7]]]]],1],[-1,-2,[],[]],0,0,[-1,-2,[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,11,[]]],"c":[],"p":[[3,"HopkarpResult",0],[15,"tuple"],[15,"bool"],[3,"Formatter",22],[6,"Result",22],[8,"Hasher",23],[15,"usize"],[3,"Vec",24],[15,"slice"],[4,"Result",25],[3,"TypeId",26]]},\
"hungarian":{"doc":"Solve an assignment problem by Hungarian algorithm.","t":"DIMLLLLLLLMLFKLMMLLLLMK","n":["HungarianResult","Value","backward","borrow","borrow_mut","clone","clone_into","eq","equivalent","fmt","forward","from","hungarian","infinity","into","left","right","to_owned","try_from","try_into","type_id","value","zero"],"q":[[0,"hungarian"],[23,"core::clone"],[24,"core::cmp"],[25,"core::fmt"],[26,"core::fmt"],[27,"core::result"],[28,"core::any"]],"d":["A value object to represent the optimal solution of an …","A trait to adapt a value type to <code>hungarian</code>","Takes the second component of a match and returns the …","","","","","","","","Takes the first component of a match and returns the …","Returns the argument unchanged.","See the crate level documentation","","Calls <code>U::from(self)</code>.","A left half of an optimal potential.","A right half of an optimal potential.","","","","","The value of an optimal solution.",""],"i":[0,0,1,1,1,1,1,1,1,1,1,1,0,3,1,1,1,1,1,1,1,1,3],"f":[0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],[2,3]],[[-1,-2],4,[],[]],[[[1,[-1]],[1,[-1]]],5,[6,3]],[[-1,-2],5,[],[]],[[[1,[-1]],7],8,[9,3]],0,[-1,-1,[]],[[[11,[[10,[-1]]]]],[[1,[-1]]],3],[[],-1,[]],[-1,-2,[],[]],0,0,[-1,-2,[],[]],[-1,[[12,[-2]]],[],[]],[-1,[[12,[-2]]],[],[]],[-1,13,[]],0,[[],-1,[]]],"c":[],"p":[[3,"HungarianResult",0],[8,"Clone",23],[8,"Value",0],[15,"tuple"],[15,"bool"],[8,"PartialEq",24],[3,"Formatter",25],[6,"Result",25],[8,"Debug",25],[3,"Vec",26],[15,"slice"],[4,"Result",27],[3,"TypeId",28]]},\
"interval_heap":{"doc":"Interval Heaps","t":"DLLLLLLLLLLLLLLLLLLLLLLLL","n":["IntervalHeap","borrow","borrow_mut","clone","clone_into","default","eq","equivalent","extend","fmt","from","from","from_iter","into","into_iter","new","peek_max","peek_min","pop_max","pop_min","push","to_owned","try_from","try_into","type_id"],"q":[[0,"interval_heap"],[25,"core::clone"],[26,"core::cmp"],[27,"core::cmp"],[28,"core::fmt"],[29,"core::fmt"],[30,"core::option"],[31,"core::result"],[32,"core::any"]],"d":["Interval heap (double-ended priority queue)","","","","","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","Constructs a new, empty interval heap.","Returns $\\\\max(S)$.","Returns $\\\\min(S)$.","Removes and returns $\\\\max(S)$.","Removes and returns $\\\\min(S)$.","$S \\\\leftarrow S \\\\cup \\\\{\\\\!\\\\{x\\\\}\\\\!\\\\}$.","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],[2,3]],[[-1,-2],4,[],[]],[[],[[1,[-1]]],3],[[[1,[-1]],[1,[-1]]],5,[6,3]],[[-1,-2],5,[],[]],[[[1,[-1]],-2],4,3,7],[[[1,[-1]],8],9,[10,3]],[-1,-1,[]],[[[11,[-1]]],[[1,[-1]]],3],[-1,[[1,[-2]]],7,3],[-1,-2,[],[]],[[[1,[-1]]],[],3],[[],[[1,[-1]]],3],[[[1,[-1]]],[[12,[-1]]],3],[[[1,[-1]]],[[12,[-1]]],3],[[[1,[-1]]],[[12,[-1]]],3],[[[1,[-1]]],[[12,[-1]]],3],[[[1,[-1]],-1],4,3],[-1,-2,[],[]],[-1,[[13,[-2]]],[],[]],[-1,[[13,[-2]]],[],[]],[-1,14,[]]],"c":[],"p":[[3,"IntervalHeap",0],[8,"Clone",25],[8,"Ord",26],[15,"tuple"],[15,"bool"],[8,"PartialEq",26],[8,"IntoIterator",27],[3,"Formatter",28],[6,"Result",28],[8,"Debug",28],[3,"Vec",29],[4,"Option",30],[4,"Result",31],[3,"TypeId",32]]},\
"io":{"doc":"Read input from stdin and parse it.","t":"IFK","n":["ParseLine","input","parse_line"],"q":[[0,"io"]],"d":["Trait for types that can be parsed.","Read input from stdin and parse it.",""],"i":[0,0,1],"f":[0,[[],-1,1],[2,-1,[]]],"c":[],"p":[[8,"ParseLine",0],[15,"str"]]},\
"lagrange":{"doc":"ラグランジュ補完","t":"FFFF","n":["evaluate","interpolate","interpolate_first_n","interpolate_one_point_first_n"],"q":[[0,"lagrange"],[4,"fp"],[5,"alloc::vec"]],"d":["多項式の係数から 1 …","x 座標の異なるような N 点の評価から、N - 1 …","0..N の評価から、N - 1 …","0..N での評価から決まる N - 1 …"],"i":[0,0,0,0],"f":[[[[2,[1]],1],1],[[[2,[[3,[1]]]]],[[4,[1]]]],[[[2,[1]]],[[4,[1]]]],[[[2,[1]],1],1]],"c":[],"p":[[3,"Fp",4],[15,"slice"],[15,"array"],[3,"Vec",5]]},\
"lazy_segbeats":{"doc":"","t":"IDLLLLLLLLLLLKKKLFLLLLLLLLK","n":["Elm","Segbeats","borrow","borrow_mut","change_max","change_min","clone","clone_into","eq","equivalent","fmt","from","into","max_value","min_value","mul_u32","new","open","query_max","query_min","query_sum","range_add","to_owned","try_from","try_into","type_id","zero"],"q":[[0,"lazy_segbeats"],[27,"core::clone"],[28,"core::ops::range"],[29,"core::cmp"],[30,"core::fmt"],[31,"core::fmt"],[32,"core::any"]],"d":["","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","",""],"i":[0,0,1,1,1,1,1,1,1,1,1,1,1,3,3,3,1,0,1,1,1,1,1,1,1,1,3],"f":[0,0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]],-2,-1],2,3,[4,[6,[5]]]],[[[1,[-1]],-2,-1],2,3,[4,[6,[5]]]],[[[1,[-1]]],[[1,[-1]]],4],[[-1,-2],2,[],[]],[[[1,[-1]],[1,[-1]]],7,8],[[-1,-2],7,[],[]],[[[1,[-1]],9],10,11],[-1,-1,[]],[-1,-2,[],[]],[[],-1,[]],[[],-1,[]],[[-1,12],-1,[]],[[[13,[-1]]],[[1,[-1]]],3],[[5,-1],[[14,[5]]],[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[[[1,[-1]],-2,-1],2,3,[4,[6,[5]]]],[-1,-2,[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,16,[]],[[],-1,[]]],"c":[],"p":[[3,"Segbeats",0],[15,"tuple"],[8,"Elm",0],[8,"Clone",27],[15,"usize"],[8,"RangeBounds",28],[15,"bool"],[8,"PartialEq",29],[3,"Formatter",30],[6,"Result",30],[8,"Debug",30],[15,"u32"],[15,"slice"],[3,"Range",28],[4,"Result",31],[3,"TypeId",32]]},\
"lazy_segtree":{"doc":"LazySegtree","t":"DIQQKLLLLLKLLLLLKKLLKLLLLL","n":["LazySegtree","Op","Operator","Value","apply","borrow","borrow_mut","clone","clone_into","collect","compose","fmt","fold","from","from_iter","get","identity","identity_op","into","new","op","range_apply","to_owned","try_from","try_into","type_id"],"q":[[0,"lazy_segtree"],[26,"core::clone"],[27,"alloc::vec"],[28,"core::fmt"],[29,"core::fmt"],[30,"core::iter::traits::collect"],[31,"core::result"],[32,"core::any"]],"d":["A lazy segment tree.","Opertions for a lazy segment tree.","The operator type.","The value type.","Applies an operator to a value.","","","","","Returns the values as a vector. It takes $O(n \\\\log n)$ …","Composes two operators. The result of <code>compose(a, b)</code> is …","","Folds a range.","Returns the argument unchanged.","","Returns the value at the index <code>i</code>.","Returns the identity value.","Returns the identity operator.","Calls <code>U::from(self)</code>.","Constructs a new lazy segment tree. You can use <code>from_iter</code> …","Multiplies two values.","Applies an operator to a range.","","","",""],"i":[0,0,3,3,3,1,1,1,1,1,3,1,1,1,1,1,3,3,1,1,3,1,1,1,1,1],"f":[0,0,0,0,[[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],[2,3]],[[-1,-2],4,[],[]],[[[1,[-1]]],5,3],[[]],[[[1,[-1]],6],7,[8,3]],[[[1,[-1]],-2],[],3,[[10,[9]]]],[-1,-1,[]],[-1,[[1,[-2]]],11,3],[[[1,[-1]],9],[],3],[[]],[[]],[-1,-2,[],[]],[12,[[1,[-1]]],3],[[]],[[[1,[-1]],-2],4,3,[[10,[9]]]],[-1,-2,[],[]],[-1,[[13,[-2]]],[],[]],[-1,[[13,[-2]]],[],[]],[-1,14,[]]],"c":[],"p":[[3,"LazySegtree",0],[8,"Clone",26],[8,"Op",0],[15,"tuple"],[3,"Vec",27],[3,"Formatter",28],[6,"Result",28],[8,"Debug",28],[15,"usize"],[8,"RangeBounds",29],[8,"IntoIterator",30],[15,"slice"],[4,"Result",31],[3,"TypeId",32]]},\
"lg":{"doc":"","t":"FFFFOFOOFOFFOFO","n":["align_of","bools","format","hmap","hmap","hvec","hvec","lg","remove_ampersand","table","vec2","vmap","vmap","vvec","vvec"],"q":[[0,"lg"],[15,"alloc::string"],[16,"core::iter::traits::collect"],[17,"core::fmt"],[18,"core::marker"],[19,"alloc::vec"]],"d":["","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"f":[0,[-1,2,3],[-1,2,4],0,0,0,0,0,[1,1],0,0,0,0,0,0],"c":[],"p":[[15,"str"],[3,"String",15],[8,"IntoIterator",16],[8,"Debug",17],[8,"Copy",18],[3,"Vec",19],[15,"tuple"],[15,"slice"]]},\
"lin_ineq":{"doc":"一次不等式を解きます。","t":"DSSISLLLLLKLLLLLLLLLLLLLLFFLLLL","n":["Interval","MAX","MIN","Signed","ZERO","borrow","borrow_mut","clone","clone_into","contains","div_euclid","empty","fmt","from","full","intersection","into","is_empty","mul","mul","mul","mul","normalize","product","product","solve","solve_squeeze","to_owned","try_from","try_into","type_id"],"q":[[0,"lin_ineq"],[31,"core::clone"],[32,"core::fmt"],[33,"core::fmt"],[34,"core::result"],[35,"core::any"]],"d":["閉区間を表す、<code>[T; 2]</code> …","","","符号付き整数です。","","","","","","…","","標準形の空区間を返します。具体的には、…","<code>Interval</code> 型のオブジェクトを human readable …","Returns the argument unchanged.","全区間を返します。具体的には、<code>[MIN, MAX]</code> …","区間の交差を計算します。","Calls <code>U::from(self)</code>.","空区間であるかどうかを判定します。","<code>intersection()</code> を呼び出します。","<code>intersection()</code> を呼び出します。","<code>intersection()</code> を呼び出します。","<code>intersection()</code> を呼び出します。","…","<code>intersection()</code> で畳み込みます。","<code>intersection()</code> で畳み込みます。","基本形 ax &lt;= b","挟み撃ち形 l &lt;= ax + b &lt;= r","","","",""],"i":[0,5,5,0,5,1,1,1,1,1,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1],"f":[0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],2],[[-1,-2],3,[],[]],[[[1,[-1]],-1],4,5],[[-1,-1],-1,[]],[[],[[1,[-1]]],5],[[[1,[-1]],6],7,[8,5]],[-1,-1,[]],[[],[[1,[-1]]],5],[[[1,[-1]],[1,[-1]]],[[1,[-1]]],5],[-1,-2,[],[]],[[[1,[-1]]],4,5],[[[1,[-1]],[1,[-1]]],[],5],[[[1,[-1]],[1,[-1]]],[],5],[[[1,[-1]],[1,[-1]]],[],5],[[[1,[-1]],[1,[-1]]],[],5],[[[1,[-1]]],[[1,[-1]]],5],[-1,[[1,[-2]]],9,5],[-1,[[1,[-2]]],9,5],[[-1,-1],[[1,[-1]]],5],[[-1,-1,[1,[-1]]],[[1,[-1]]],5],[-1,-2,[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,11,[]]],"c":[],"p":[[3,"Interval",0],[8,"Clone",31],[15,"tuple"],[15,"bool"],[8,"Signed",0],[3,"Formatter",32],[6,"Result",32],[8,"Debug",32],[8,"Iterator",33],[4,"Result",34],[3,"TypeId",35]]},\
"link_cut_tree":{"doc":"Link-Cut Tree","t":"GGDGIQLLLLLLLKLLLKLLLLLLLLLLL","n":["CommutLinkCutTree","LinkCutTree","LinkCutTreeBase","NonCommutLinkCutTree","Op","Value","borrow","borrow_mut","cut","evert","fold","from","from_values","identity","into","lca","link","mul","new","parent","set","try_from","try_into","type_id","undirected_cut","undirected_fold","undirected_has_edge","undirected_is_connected","undirected_link"],"q":[[0,"link_cut_tree"],[29,"core::option"],[30,"core::iter::traits::collect"],[31,"core::ops::function"],[32,"core::result"],[33,"core::any"]],"d":["Link-Cut Tree with commutative operation","Link-Cut Tree without aggregation operation","Common implementation of Link-Cut Tree. Please do not use …","Link-Cut Tree with non-commutative operation","Aggregation operation for link-cut tree","","","","Cuts the edge between <code>x</code> and its parent.","Makes <code>x</code> the root of the tree.","Folds the path from the root to <code>x</code>.","Returns the argument unchanged.","Constructs a new Link-Cut Tree with <code>n</code> nodes, where the …","","Calls <code>U::from(self)</code>.","Returns the id of the lowest common ancestor of <code>x</code> and <code>y</code>.","Connects <code>p</code> and <code>c</code> with an edge, preserving the direction.","","Constructs a new Link-Cut Tree with <code>n</code> nodes.","Returns the id of the parent of <code>x</code>.","Sets the value of <code>x</code> to <code>f(x)</code>.","","","","Cuts the edge between <code>i</code> and <code>j</code>, not preserving the …","Folds the path from <code>i</code> to <code>j</code>, not preserving the direction.","Returns <code>true</code> if there is an edge between <code>x</code> and <code>y</code>.","Returns <code>true</code> if <code>x</code> and <code>y</code> are connected.","Connects <code>i</code> and <code>j</code> with an edge, not preserving the …"],"i":[0,0,0,0,0,10,1,1,1,1,1,1,1,10,1,1,1,10,1,1,1,1,1,1,1,1,1,1,1],"f":[0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]],2],[[3,[2]]],0],[[[1,[-1]],2],4,0],[[[1,[-1]],2],[],0],[-1,-1,[]],[-1,[[1,[-2]]],5,0],[[]],[-1,-2,[],[]],[[[1,[-1]],2,2],[[3,[2]]],0],[[[1,[-1]],2,2],4,0],[[]],[2,[[1,[-1]]],0],[[[1,[-1]],2],[[3,[2]]],0],[[[1,[-1]],2,-2],4,0,6],[-1,[[7,[-2]]],[],[]],[-1,[[7,[-2]]],[],[]],[-1,8,[]],[[[1,[-1]],2,2],9,0],[[[1,[-1]],2,2],3,0],[[[1,[-1]],2,2],9,0],[[[1,[-1]],2,2],9,0],[[[1,[-1]],2,2],9,0]],"c":[],"p":[[3,"LinkCutTreeBase",0],[15,"usize"],[4,"Option",29],[15,"tuple"],[8,"IntoIterator",30],[8,"FnMut",31],[4,"Result",32],[3,"TypeId",33],[15,"bool"],[8,"Op",0]]},\
"low_link":{"doc":"Low-link を計算します。","t":"DLLLLLLLLLLLLLLLLLLLLLL","n":["LowLink","add_edge","biconnected_components","borrow","borrow_mut","build","clone","clone_into","default","eq","equivalent","fmt","from","hash","into","is_articulation_point","is_bridge_unchecked","new","to_owned","try_from","try_into","two_edge_components","type_id"],"q":[[0,"low_link"],[23,"alloc::vec"],[24,"core::fmt"],[25,"core::fmt"],[26,"core::result"],[27,"core::any"]],"d":["Low-link を計算する構造体です。","…","…","","","ビルドします。","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","頂点 <code>x</code> が関節点なら <code>true</code> を返します。","頂点 <code>x</code>, <code>y</code> …","未ビルドの空グラフを構築します。","","","","…",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[[1,2,2],3],[1,[[5,[[5,[[4,[2]]]]]]]],[-1,-2,[],[]],[-1,-2,[],[]],[1,3],[1,1],[[-1,-2],3,[],[]],[[],1],[[1,1],6],[[-1,-2],6,[],[]],[[1,7],8],[-1,-1,[]],[[1,-1],3,9],[-1,-2,[],[]],[[1,2],6],[[1,2,2],6],[2,1],[-1,-2,[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[1,[[5,[[5,[2]]]]]],[-1,11,[]]],"c":[],"p":[[3,"LowLink",0],[15,"usize"],[15,"tuple"],[15,"array"],[3,"Vec",23],[15,"bool"],[3,"Formatter",24],[6,"Result",24],[8,"Hasher",25],[4,"Result",26],[3,"TypeId",27]]},\
"manacher":{"doc":"Manacher’s algorithm","t":"F","n":["manacher"],"q":[[0,"manacher"],[1,"alloc::vec"],[2,"core::cmp"]],"d":["Returns the palindrome array $A$ of the given string $s$."],"i":[0],"f":[[[[1,[-1]]],[[3,[2]]],4]],"c":[],"p":[[15,"slice"],[15,"usize"],[3,"Vec",1],[8,"Eq",2]]},\
"mincost_flow":{"doc":"Dijkstra …","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["Edge","MinCostFlow","add_edge","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","default","default","eq","eq","equivalent","flow","fmt","fmt","from","from","get_edge","hash","hash","into","into","new","slope","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"mincost_flow"],[36,"core::fmt"],[37,"core::fmt"],[38,"alloc::vec"],[39,"core::result"],[40,"core::any"]],"d":["<code>MinCostFlow::get_edge</code> の戻り値型","Dijkstra …","辺を追加します。","","","","","","","","","","","","","","解きます","","","Returns the argument unchanged.","Returns the argument unchanged.","<code>i</code> 番目に挿入した辺を取得します。","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","空グラフを構築します。","解きます","","","","","","","",""],"i":[0,0,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,1,4,1,4,1,1,1,4,1,4,1,4,1,4,1],"f":[0,0,[[1,2,2,3,3],2],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[4,4],[1,1],[[-1,-2],5,[],[]],[[-1,-2],5,[],[]],[[],4],[[],1],[[4,4],6],[[1,1],6],[[-1,-2],6,[],[]],[[1,2,2,3],[[5,[3,3]]]],[[4,7],8],[[1,7],8],[-1,-1,[]],[-1,-1,[]],[[1,2],4],[[4,-1],5,9],[[1,-1],5,9],[-1,-2,[],[]],[-1,-2,[],[]],[2,1],[[1,2,2,3],[[10,[[5,[3,3]]]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,[[11,[-2]]],[],[]],[-1,12,[]],[-1,12,[]]],"c":[],"p":[[3,"MinCostFlow",0],[15,"usize"],[15,"i64"],[3,"Edge",0],[15,"tuple"],[15,"bool"],[3,"Formatter",36],[6,"Result",36],[8,"Hasher",37],[3,"Vec",38],[4,"Result",39],[3,"TypeId",40]]},\
"monotone_minima":{"doc":"Monotone minima のアルゴリズムと、それによる …","t":"FFFFFF","n":["concave_maxplus_convolution","convex_minplus_convolution","monotone_maxima","monotone_maxima_by","monotone_minima","monotone_minima_by"],"q":[[0,"monotone_minima"],[6,"alloc::vec"],[7,"core::marker"],[8,"core::cmp"],[9,"core::ops::arith"],[10,"core::ops::function"],[11,"core::ops::function"]],"d":["concave な列に対して max-plus convolution …","convex な列に対して min-plus convolution …","行列 <code>f(i, j)</code> を受け取って、monotone maxima …","行ごとのセル比較 <code>cmp(i, j, k)</code> …","行列 <code>f(i, j)</code> を受け取って、monotone minima …","行ごとのセル比較 <code>cmp(i, j, k)</code> …"],"i":[0,0,0,0,0,0],"f":[[[[1,[-1]],[1,[-1]]],[[2,[-1]]],[3,4,5]],[[[1,[-1]],[1,[-1]]],[[2,[-1]]],[3,4,5]],[[6,6,-1],[[2,[6]]],7],[[6,6,-1],[[2,[6]]],[8,3]],[[6,6,-1],[[2,[6]]],7],[[6,6,-1],[[2,[6]]],[8,3]]],"c":[],"p":[[15,"slice"],[3,"Vec",6],[8,"Copy",7],[8,"Ord",8],[8,"Add",9],[15,"usize"],[8,"Fn",10],[8,"FnMut",10]]},\
"naive_poly":{"doc":"Naive implementation of polynomial operations","t":"FFFFFF","n":["add","div","eval","mul","pow","sub"],"q":[[0,"naive_poly"],[6,"alloc::vec"]],"d":["Add two polynomials in $O(\\\\max(n, m))$ time.","Divide two polynomials in $O((n - m) m)$ time.","Evaluate a polynomial at a point in $O(n)$ time.","Multiply two polynomials in $O(nm)$ time.","Compute the $e$-th power of a polynomial in $O((en)^2 \\\\log …","Subtract two polynomials in $O(\\\\max(n, m))$ time."],"i":[0,0,0,0,0,0],"f":[[[[1,[-1]],[1,[-1]]],[[2,[-1]]],[]],[[[2,[-1]],[1,[-1]]],[[2,[-1]]],[]],[[[1,[-1]],-1],-1,[]],[[[1,[-1]],[1,[-1]]],[[2,[-1]]],[]],[[[2,[-1]],3],[[2,[-1]]],[]],[[[1,[-1]],[1,[-1]]],[[2,[-1]]],[]]],"c":[],"p":[[15,"slice"],[3,"Vec",6],[15,"u64"]]},\
"newton":{"doc":"","t":"FF","n":["sqrt","triangular_root"],"q":[[0,"newton"]],"d":["",""],"i":[0,0],"f":[[1,1],[1,1]],"c":[],"p":[[15,"u64"]]},\
"next_permutation":{"doc":"A library to enumerate permutations, shuffles, and …","t":"FFFFFFFFFFFFFFF","n":["for_each_pairing","for_each_partition","for_each_partition_rev","for_each_permutation","for_each_shuffle","next_pairing","next_partition","next_permutation","next_shuffle","pairings","partitions","partitions_rev","permutations","prev_partition","shuffles"],"q":[[0,"next_permutation"],[15,"core::ops::function"],[16,"core::cmp"],[17,"alloc::vec"],[18,"core::clone"]],"d":["Calls <code>f</code> for each pairing (ascending …","Calls <code>f</code> for each partition of <code>n</code> in lexicographic order.","Calls <code>f</code> for each partition of <code>n</code> in the reverse of the …","Calls <code>f</code> for each permutation of <code>a</code> in lexicographic order.","Calls <code>f</code> for each $(K, N - K)$-shuffle of <code>a</code> in …","Returns the next pairing (ascending …","Returns the next partition of <code>a</code> in lexicographic order.","Returns the next permutation of <code>a</code> in lexicographic order.","Returns the next $(K, N - K)$-shuffle of <code>a</code> in …","Returns all pairings (ascending $(2,2,\\\\dots,2)$-shuffles) …","Returns all partitions of <code>n</code> in lexicographic order.","Returns all partitions of <code>n</code> in the reverse of the …","Returns all permutations of <code>a</code> in lexicographic order.","Returns the previous partition of <code>a</code> in lexicographic order.","Returns all $(K, N - K)$-shuffles of <code>a</code> in lexicographic …"],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"f":[[[1,-1],2,3],[[1,-1],2,3],[[1,-1],2,3],[[[4,[-1]],-2],2,5,3],[[[4,[-1]],1,-2],2,5,3],[[[4,[1]]],6],[[[7,[1]]],6],[[[4,[-1]]],6,5],[[[4,[-1]],1],6,5],[1,[[7,[[7,[1]]]]]],[1,[[7,[[7,[1]]]]]],[1,[[7,[[7,[1]]]]]],[[[7,[-1]]],[[7,[[7,[-1]]]]],[5,8]],[[[7,[1]]],6],[[[7,[-1]],1],[[7,[[7,[-1]]]]],[5,8]]],"c":[],"p":[[15,"usize"],[15,"tuple"],[8,"FnMut",15],[15,"slice"],[8,"Ord",16],[15,"bool"],[3,"Vec",17],[8,"Clone",18]]},\
"numeric_search":{"doc":"Run classic binary or exponential search on integer or …","t":"ISSSSSSSIISSSFFFFFK","n":["Float","INFINITY","MAX","MIN","NEG_INFINITY","ONE","ONE","ONE","Signed","Unsigned","ZERO","ZERO","ZERO","binary_search_signed","binary_search_unsigned","exp_search_float","exp_search_signed","exp_search_unsigned","sqrt"],"q":[[0,"numeric_search"],[19,"core::ops::function"],[20,"core::option"]],"d":["Floating pont number.","$\\\\infty$","","","$-\\\\infty$","$1$","$1$","","Signed integers.","Unsigned integers.","$0$","$0$","","Run a binary search search on signed numbers.","Run a binary search search on unsigned numbers.","Run an exponential search on floating point numbers.","Run an exponential search on unsigned numbers.","Run an exponential search on unsigned numbers.","$x \\\\mapsto \\\\sqrt x$"],"i":[0,4,1,1,4,4,3,1,0,0,4,3,1,0,0,0,0,0,4],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,[[-1,-1,-2],-1,1,2],[[-1,-1,-2],-1,3,2],[-1,-2,2,4],[-1,[[5,[-2]]],2,1],[-1,[[5,[-2]]],2,3],[-1,-1,[]]],"c":[],"p":[[8,"Signed",0],[8,"FnMut",19],[8,"Unsigned",0],[8,"Float",0],[4,"Option",20]]},\
"partially_persistent_union_find":{"doc":"…","t":"DLLLLLLLLLLLLLLLLL","n":["PartiallyPersistentUnionFind","borrow","borrow_mut","clone","clone_into","find","fmt","from","into","new","same","size","time","to_owned","try_from","try_into","type_id","union"],"q":[[0,"partially_persistent_union_find"],[18,"core::fmt"],[19,"core::fmt"],[20,"core::result"],[21,"core::any"]],"d":["…","","","","","時刻 time の代表の頂点番号を返します。","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","新しくデータ構造を構築します。","時刻 time に i と j …","時刻 time の i …","2 頂点が結合された時刻を返します。","","","","","…"],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[[-1,-2],2,[],[]],[[1,3,3],3],[[1,4],5],[-1,-1,[]],[-1,-2,[],[]],[3,1],[[1,3,3,3],6],[[1,3,3],3],[[1,3,3],[[7,[3]]]],[-1,-2,[],[]],[-1,[[8,[-2]]],[],[]],[-1,[[8,[-2]]],[],[]],[-1,9,[]],[[1,3,3,3],6]],"c":[],"p":[[3,"PartiallyPersistentUnionFind",0],[15,"tuple"],[15,"usize"],[3,"Formatter",18],[6,"Result",18],[15,"bool"],[4,"Option",19],[4,"Result",20],[3,"TypeId",21]]},\
"randtools":{"doc":"","t":"DDDDDDDDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["DistinctTwo","LogUniform","NonEmptySubRange","SimpleDigraph","SimpleDigraphEdges","SimpleGraph","SimpleGraphEdges","SubRange","Tree","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","into","into","into","into","into","into","into","into","into","sample","sample","sample","sample","sample","sample","sample","sample","sample","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","vzip","vzip","vzip","vzip","vzip","vzip","vzip","vzip","vzip"],"q":[[0,"randtools"],[99,"core::fmt"],[100,"core::fmt"],[101,"core::marker"],[102,"core::ops::range"],[103,"alloc::vec"],[104,"core::result"],[105,"core::any"]],"d":["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,0,0,0,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11,1,4,5,6,7,8,9,10,11],"f":[0,0,0,0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[1,2],3],[[4,2],3],[[5,2],3],[[6,2],3],[[7,2],3],[[8,2],3],[[9,2],3],[[10,2],3],[[11,2],3],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[1,-1],12,[13,14]],[[4,-1],[[15,[12,12]]],[13,14]],[[5,-1],[[16,[12]]],[13,14]],[[6,-1],[[16,[12]]],[13,14]],[[7,-1],[[17,[[17,[12]]]]],[13,14]],[[8,-1],[[17,[[17,[12]]]]],[13,14]],[[9,-1],[[17,[[17,[12]]]]],[13,14]],[[10,-1],[[17,[[15,[12,12]]]]],[13,14]],[[11,-1],[[17,[[15,[12,12]]]]],[13,14]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,[[18,[-2]]],[],[]],[-1,19,[]],[-1,19,[]],[-1,19,[]],[-1,19,[]],[-1,19,[]],[-1,19,[]],[-1,19,[]],[-1,19,[]],[-1,19,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]]],"c":[],"p":[[3,"LogUniform",0],[3,"Formatter",99],[6,"Result",99],[3,"DistinctTwo",0],[3,"SubRange",0],[3,"NonEmptySubRange",0],[3,"Tree",0],[3,"SimpleGraph",0],[3,"SimpleDigraph",0],[3,"SimpleGraphEdges",0],[3,"SimpleDigraphEdges",0],[15,"usize"],[8,"Rng",100],[8,"Sized",101],[15,"tuple"],[3,"Range",102],[3,"Vec",103],[4,"Result",104],[3,"TypeId",105]]},\
"rational":{"doc":"","t":"DILLLLLLLLLLLLLLLLLLLLLLKKLLLLLLLLLKLLLLLLLLLLLLLLK","n":["Rational","Signed","add","add","add","add","add_assign","borrow","borrow_mut","clone","clone_into","cmp","decompose","default","div","div","div","div","div_assign","eq","equivalent","fmt","from","from_str","generic_abs","generic_signum","into","into_f64","mul","mul","mul","mul","mul_assign","neg","new","one","partial_cmp","product","product","sub","sub","sub","sub","sub_assign","sum","sum","to_owned","try_from","try_into","type_id","zero"],"q":[[0,"rational"],[51,"core::clone"],[52,"core::cmp"],[53,"core::default"],[54,"core::fmt"],[55,"core::fmt"],[56,"core::option"],[57,"core::iter::traits::iterator"],[58,"core::any"]],"d":["","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2],"f":[0,0,[[[1,[-1]],[1,[-1]]],[[1,[-1]]],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],3,2],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],[4,2]],[[-1,-2],3,[],[]],[[[1,[-1]],[1,[-1]]],5,2],[[[1,[-1]]],[[6,[-1]]],2],[[],[[1,[-1]]],[7,2]],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[[1,[-1]]],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],3,2],[[[1,[-1]],[1,[-1]]],8,2],[[-1,-2],8,[],[]],[[[1,[-1]],9],10,2],[-1,-1,[]],[11,[[12,[[1,[-1]]]]],2],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[[[1,[-1]]],13,2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[[1,[-1]]],2],[[[1,[-1]],[1,[-1]]],3,2],[[[1,[-1]]],[],2],[[-1,-1],[[1,[-1]]],2],[[],-1,[]],[[[1,[-1]],[1,[-1]]],[[14,[5]]],2],[-1,[[1,[-2]]],15,2],[-1,[[1,[-2]]],15,2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[],2],[[[1,[-1]],[1,[-1]]],[[1,[-1]]],2],[[[1,[-1]],[1,[-1]]],3,2],[-1,[[1,[-2]]],15,2],[-1,[[1,[-2]]],15,2],[-1,-2,[],[]],[-1,[[12,[-2]]],[],[]],[-1,[[12,[-2]]],[],[]],[-1,16,[]],[[],-1,[]]],"c":[],"p":[[3,"Rational",0],[8,"Signed",0],[15,"tuple"],[8,"Clone",51],[4,"Ordering",52],[15,"array"],[8,"Default",53],[15,"bool"],[3,"Formatter",54],[6,"Result",54],[15,"str"],[4,"Result",55],[15,"f64"],[4,"Option",56],[8,"Iterator",57],[3,"TypeId",58]]},\
"rb":{"doc":"Containers for storing data in a red-black tree.","t":"QDIDDIDQQLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLKLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLL","n":["Acc","Multimap","MultimapOp","MultimapSeg","Multiset","Op","Seg","Value","Value","append","binary_search","binary_search","binary_search","binary_search_ptr","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","default","default","default","default","display","fmt","fmt","fmt","fold","from","from","from","from","from_iter","identity","insert","insert","insert","insert","into","into","into","into","into_iter","into_iter","into_iter","into_iter","is_empty","is_empty","is_empty","is_empty","iter","iter","iter","iter","join","len","len","len","len","lower_bound","lower_bound","lower_bound","mul","new","new","new","new","nth","nth","nth","nth","nth_mut","nth_mut","partition_point","partition_point","partition_point","remove","remove","remove","remove","remove_nth","remove_nth","remove_nth","split_off","table","to_acc","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","upper_bound","upper_bound","upper_bound"],"q":[[0,"rb"],[104,"core::result"],[105,"core::cmp"],[106,"core::marker"],[107,"core::borrow"],[108,"core::fmt"],[109,"core::fmt"],[110,"core::iter::traits::collect"],[111,"core::option"],[112,"core::ops::function"],[113,"core::any"]],"d":["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[10,0,0,0,0,0,0,10,3,1,4,11,12,4,4,11,12,1,4,11,12,1,4,11,12,1,1,11,12,1,1,4,11,12,1,1,3,4,11,12,1,4,11,12,1,4,11,12,1,4,11,12,1,4,11,12,1,10,4,11,12,1,4,11,12,3,4,11,12,1,4,11,12,1,4,1,4,11,12,4,11,12,1,4,11,12,1,1,10,4,11,12,1,4,11,12,1,4,11,12,1,4,11,12],"f":[0,0,0,0,0,0,0,0,0,[[[1,[-1]],[1,[-1]]],2,3],[[[4,[-2,-3]],-1],[[6,[[2,[5]],5]]],[7,8],[7,[9,[-1]],7],10],[[[11,[-2,-3]],-1],[[6,[[2,[-3,5]],5]]],[7,8],[7,[9,[-1]],7],[]],[[[12,[-2]],-1],[[6,[5,5]]],[7,8],[7,[9,[-1]],7]],[[[4,[-2,-3]],-1],[[6,[[2,[[0,[[0,[-2,-3]]]],5]],5]]],[7,8],[7,[9,[-1]],7],10],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[],[[4,[-1,-2]]],7,10],[[],[[11,[-1,-2]]],7,[]],[[],[[12,[-1]]],7],[[],[[1,[-1]]],3],[[[1,[-1]]],[[0,[-1]]],3],[[[11,[-1,-2]],13],14,[7,15],15],[[[12,[-1]],13],14,[7,15]],[[[1,[-1]],13],14,3],[[[1,[-1]],-2],[],3,[[16,[5]]]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,[[1,[-2]]],17,3],[[]],[[[4,[-1,-2]],-1],2,7,10],[[[11,[-1,-2]],-1,-2],2,7,[]],[[[12,[-1]],-1],2,7],[[[1,[-1]],5],2,3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[4,[-1,-2]]],[],7,10],[[[11,[-1,-2]]],[],7,[]],[[[12,[-1]]],[],7],[[[1,[-1]]],[],3],[[[4,[-1,-2]]],18,7,10],[[[11,[-1,-2]]],18,7,[]],[[[12,[-1]]],18,7],[[[1,[-1]]],18,3],[[[4,[-1,-2]]],[[0,[-1,-2]]],7,10],[[[11,[-1,-2]]],[[0,[-1,-2]]],7,[]],[[[12,[-1]]],[[0,[-1]]],7],[[[1,[-1]]],[[0,[-1]]],3],[[19,19]],[[[4,[-1,-2]]],5,7,10],[[[11,[-1,-2]]],5,7,[]],[[[12,[-1]]],5,7],[[[1,[-1]]],5,3],[[[4,[-1,-2]],-1],5,7,10],[[[11,[-1,-2]],-1],5,7,[]],[[[12,[-1]],-1],5,7],[[]],[[],[[4,[-1,-2]]],7,10],[[],[[11,[-1,-2]]],7,[]],[[],[[12,[-1]]],7],[[],[[1,[-1]]],3],[[[4,[-1,-2]],5],[[2,[-1]]],7,10],[[[11,[-1,-2]],5],[[2,[-1,-2]]],7,[]],[[[12,[-1]],5],-1,7],[[[1,[-1]],5],[],3],[[[4,[-1,-2]],5],[[2,[-1]]],7,10],[[[1,[-1]],5],[[0,[-1]]],3],[[[4,[-1,-2]],-3],5,7,10,20],[[[11,[-1,-2]],-3],5,7,[],20],[[[12,[-1]],-2],5,7,20],[[[4,[-2,-3]],-1],[[19,[[2,[-2]]]]],[7,8],[7,[9,[-1]],7],10],[[[11,[-2,-3]],-1],[[19,[[2,[-2,-3]]]]],[7,8],[7,[9,[-1]],7],[]],[[[12,[-2]],-1],[[19,[-2]]],[7,8],[7,[9,[-1]],7]],[[[1,[-1]],5],[],3],[[[4,[-1,-2]],5],[[2,[-1]]],7,10],[[[11,[-1,-2]],5],[[2,[-1,-2]]],7,[]],[[[12,[-1]],5],-1,7],[[[1,[-1]],5],[[1,[-1]]],3],[[[1,[-1]]],[[0,[-1]]],3],[[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,21,[]],[-1,21,[]],[-1,21,[]],[-1,21,[]],[[[4,[-1,-2]],-1],5,7,10],[[[11,[-1,-2]],-1],5,7,[]],[[[12,[-1]],-1],5,7]],"c":[],"p":[[3,"Seg",0],[15,"tuple"],[8,"Op",0],[3,"MultimapSeg",0],[15,"usize"],[4,"Result",104],[8,"Ord",105],[8,"Sized",106],[8,"Borrow",107],[8,"MultimapOp",0],[3,"Multimap",0],[3,"Multiset",0],[3,"Formatter",108],[6,"Result",108],[8,"Debug",108],[8,"RangeBounds",109],[8,"IntoIterator",110],[15,"bool"],[4,"Option",111],[8,"FnMut",112],[3,"TypeId",113]]},\
"rbtree":{"doc":"赤黒木","t":"DDIDQQLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLKLLLLLLLLLLL","n":["Iter","Nop","Op","RbTree","Summary","Value","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","default","delete","eq","fmt","fold","from","from","from","from_iter","get","hash","insert","into","into","into","into_iter","into_iter","is_empty","iter","len","merge","merge3","new","next","op","op","partition_point","push_back","push_front","singleton","split","split3","summarize","summarize","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id"],"q":[[0,"rbtree"],[58,"core::clone"],[59,"core::cmp"],[60,"core::fmt"],[61,"core::fmt"],[62,"core::ops::range"],[63,"core::iter::traits::collect"],[64,"core::marker"],[65,"core::hash"],[66,"core::hash"],[67,"core::result"],[68,"core::any"]],"d":["<code>iter</code> の返す型","…","…","赤黒木です。","中間ノードに持たせる値","葉に持たせる値","","","","","","","","","","<code>i</code> 番目の Nil …","","","<code>range</code> の範囲で畳み込みます。","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","…","<code>i</code> 番目の要素をコピーして返します。","","<code>i</code> 番目に新しい Nil ノードを挿入します。","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","空ならば <code>true</code>、さもなくば <code>false</code> …","…","長さ、すなわち Nil …","2 つの赤黒木をマージします。","3 つの赤黒木をマージします。","空の赤黒木を生成します。","","演算","","中間ノードの情報で二分探索します。","新しいノードを末尾に挿入します。","新しいノードを先頭に挿入します。","Nil …","<code>i</code> 番目で分割します。","<code>l, r</code> 番目で 3 つに分割します。","葉の値から中間ノードの値への変換","","","","","","","","","","",""],"i":[0,0,0,0,3,3,1,22,17,1,22,17,1,1,1,1,1,1,1,1,22,17,1,1,1,1,1,22,17,1,17,1,1,1,1,1,1,17,3,22,1,1,1,1,1,1,3,22,1,1,22,17,1,22,17,1,22,17],"f":[0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1,-2]]],[[1,[-1,-2]]],2,3],[[-1,-2],4,[],[]],[[],[[1,[-1,-2]]],[],3],[[[1,[-1,-2]],5],-1,[],3],[[[1,[-1,-2]],[1,[-1,-2]]],6,7,3],[[[1,[-1,-2]],8],9,10,3],[[[1,[-1,-2]],-3],11,[],3,[[12,[5]]]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,[[1,[-2,-3]]],13,[],3],[[[1,[-1,-2]],5],-1,14,3],[[[1,[-1,-2]],-3],4,15,3,16],[[[1,[-1,-2]],5,-1],4,[],3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[],3],[-1,-2,[],[]],[[[1,[-1,-2]]],6,[],3],[[[1,[-1,-2]]],[[17,[-1,-2]]],[],3],[[[1,[-1,-2]]],5,[],3],[[[1,[-1,-2]],[1,[-1,-2]]],[[1,[-1,-2]]],[],3],[[[1,[-1,-2]],[1,[-1,-2]],[1,[-1,-2]]],[[1,[-1,-2]]],[],3],[[],[[1,[-1,-2]]],[],3],[[[17,[-1,-2]]],11,[],3],[[]],[[]],[[[1,[-1,-2]],-3],5,[],3,18],[[[1,[-1,-2]],-1],4,[],3],[[[1,[-1,-2]],-1],4,[],3],[-1,[[1,[-1,-2]]],[],3],[[[1,[-1,-2]],5],[[19,[[1,[-1,-2]]]]],[],3],[[[1,[-1,-2]],5,5],[[19,[[1,[-1,-2]]]]],[],3],[[]],[[]],[-1,-2,[],[]],[-1,[[20,[-2]]],[],[]],[-1,[[20,[-2]]],[],[]],[-1,[[20,[-2]]],[],[]],[-1,[[20,[-2]]],[],[]],[-1,[[20,[-2]]],[],[]],[-1,[[20,[-2]]],[],[]],[-1,21,[]],[-1,21,[]],[-1,21,[]]],"c":[],"p":[[3,"RbTree",0],[8,"Clone",58],[8,"Op",0],[15,"tuple"],[15,"usize"],[15,"bool"],[8,"PartialEq",59],[3,"Formatter",60],[6,"Result",60],[8,"Debug",60],[4,"Option",61],[8,"RangeBounds",62],[8,"IntoIterator",63],[8,"Copy",64],[8,"Hash",65],[8,"Hasher",65],[3,"Iter",0],[8,"Fn",66],[15,"array"],[4,"Result",67],[3,"TypeId",68],[3,"Nop",0]]},\
"riff":{"doc":"Future and otherworldly Rust features.","t":"SIQSSIIIIIQSLLFFLLLLKKKFLLLLLLLLLLLLKKKLLLLLLLLLLLLLLLLLLLLK","n":["BITS","ChangeMinMax","Item","MAX","ONE","PopIf","SliceAccum","SliceBinarySearch","SliceChunks","Unsigned","Value","ZERO","bit_length","bit_length","bitmask_combinations","bitmask_subsets","change_max","change_max","change_min","change_min","chunk_by","for_each_backward","for_each_forward","i2powm1","lower_bound","lower_bound","lower_bound_by","lower_bound_by","lower_bound_by_key","lower_bound_by_key","lower_bound_value","lower_bound_value","lower_bound_value_by","lower_bound_value_by","lower_bound_value_by_key","lower_bound_value_by_key","partition_point","partition_point_value","pop_if","prefix_sum","prefix_sum","prefix_sum_inv","prefix_sum_inv","suffix_sum","suffix_sum","suffix_sum_inv","suffix_sum_inv","upper_bound","upper_bound","upper_bound_by","upper_bound_by","upper_bound_by_key","upper_bound_by_key","upper_bound_value","upper_bound_value","upper_bound_value_by","upper_bound_value_by","upper_bound_value_by_key","upper_bound_value_by_key","wrapping_neg"],"q":[[0,"riff"],[60,"core::ops::function"],[61,"core::cmp"],[62,"core::option"],[63,"core::ops::function"]],"d":["","<code>change_min</code> and <code>change_max</code>","","","","Conditional <code>pop</code> function.","Prefix sum, suffix sum, etc.","<code>{lower,upper}_bound</code>, etc","Chunk by predicate.","Unsigned integer types.","","","","","Generates all the $k$-subsets of $[0, N[$","Generates all the subsets of <code>bs</code>.","","","","","Groups adjacent elements by a predicate. (Rust 1.77.0)","Apply $f$ to each adjacent pair from right to left.","Apply $f$ to each adjacent pair from left to right.","Returns $2^n - 1$.","","","","","","","","","","","","","","","","Replace $A_i$ with $\\\\sum_{j=0}^{i} A_j$.","Replace $A_i$ with $\\\\sum_{j=0}^{i} A_j$.","Replace $A_i$ with $A_i - A_{i-1}$.","Replace $A_i$ with $A_i - A_{i-1}$.","Replace $A_i$ with $\\\\sum_{j=i}^{n-1} A_j$.","Replace $A_i$ with $\\\\sum_{j=i}^{n-1} A_j$.","Replace $A_i$ with $A_i - A_{i+1}$.","Replace $A_i$ with $A_i - A_{i+1}$.","","","","","","","","","","","","",""],"i":[2,0,9,2,2,0,0,0,0,0,10,2,2,2,0,0,11,11,11,11,9,12,12,0,13,13,13,13,13,13,13,13,13,13,13,13,13,13,10,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,2],"f":[0,0,0,0,0,0,0,0,0,0,0,0,[[],1],[[],1],[[1,1],[[0,[-1]]],2],[-1,[[0,[-1]]],2],[[-1,-1],3,[]],[[-1,-1],3,[]],[[-1,-1],3,[]],[[-1,-1],3,[]],[[-1,-2],[[0,[-2]]],[],4],[[-1,-2],3,[],4],[[-1,-2],3,[],4],[1,-1,2],[[-1,-2],5,[],6],[[-1,-2],5,[],6],[[-1,-2],5,[],4],[[-1,-2],5,[],4],[[-1,-2,-3],5,[],6,4],[[-1,-2,-3],5,[],6,4],[[-1,-2],[[7,[-2]]],[],6],[[-1,-2],[[7,[-2]]],[],6],[[-1,-2],[[7,[-3]]],[],4,[]],[[-1,-2],[[7,[-3]]],[],4,[]],[[-1,-2,-3],[[7,[-4]]],[],6,4,[]],[[-1,-2,-3],[[7,[-4]]],[],6,4,[]],[[-1,-2],5,[],4],[[-1,-2],[[7,[-3]]],[],4,[]],[[-1,-2],7,[],8],[-1,3,[]],[-1,3,[]],[-1,3,[]],[-1,3,[]],[-1,3,[]],[-1,3,[]],[-1,3,[]],[-1,3,[]],[[-1,-2],5,[],6],[[-1,-2],5,[],6],[[-1,-2],5,[],4],[[-1,-2],5,[],4],[[-1,-2,-3],5,[],6,4],[[-1,-2,-3],5,[],6,4],[[-1,-2],[[7,[-2]]],[],6],[[-1,-2],[[7,[-2]]],[],6],[[-1,-2],[[7,[-3]]],[],4,[]],[[-1,-2],[[7,[-3]]],[],4,[]],[[-1,-2,-3],[[7,[-4]]],[],6,4,[]],[[-1,-2,-3],[[7,[-4]]],[],6,4,[]],[-1,-1,[]]],"c":[],"p":[[15,"u32"],[8,"Unsigned",0],[15,"tuple"],[8,"FnMut",60],[15,"usize"],[8,"Ord",61],[4,"Option",62],[8,"FnOnce",60],[8,"SliceChunks",0],[8,"PopIf",0],[8,"ChangeMinMax",0],[8,"SliceAccum",0],[8,"SliceBinarySearch",0]]},\
"segbeats":{"doc":"","t":"IDLLLLLLLLLLLKKKLFLLLLLLLK","n":["Elm","Segbeats","borrow","borrow_mut","change_max","change_min","clone","clone_into","eq","equivalent","fmt","from","into","max_value","min_value","mul_u32","new","open","query_max","query_min","query_sum","to_owned","try_from","try_into","type_id","zero"],"q":[[0,"segbeats"],[26,"core::clone"],[27,"core::ops::range"],[28,"core::cmp"],[29,"core::fmt"],[30,"core::fmt"],[31,"core::any"]],"d":["","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","",""],"i":[0,0,1,1,1,1,1,1,1,1,1,1,1,3,3,3,1,0,1,1,1,1,1,1,1,3],"f":[0,0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]],-2,-1],2,3,[4,[6,[5]]]],[[[1,[-1]],-2,-1],2,3,[4,[6,[5]]]],[[[1,[-1]]],[[1,[-1]]],4],[[-1,-2],2,[],[]],[[[1,[-1]],[1,[-1]]],7,8],[[-1,-2],7,[],[]],[[[1,[-1]],9],10,11],[-1,-1,[]],[-1,-2,[],[]],[[],-1,[]],[[],-1,[]],[[-1,12],-1,[]],[[[13,[-1]]],[[1,[-1]]],3],[[5,-1],[[14,[5]]],[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[-1,-2,[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,16,[]],[[],-1,[]]],"c":[],"p":[[3,"Segbeats",0],[15,"tuple"],[8,"Elm",0],[8,"Clone",26],[15,"usize"],[8,"RangeBounds",27],[15,"bool"],[8,"PartialEq",28],[3,"Formatter",29],[6,"Result",29],[8,"Debug",29],[15,"u32"],[15,"slice"],[3,"Range",27],[4,"Result",30],[3,"TypeId",31]]},\
"segbeats_task3":{"doc":"","t":"IDLLLLLLLLLLLLKKKLFLLLLLLLLK","n":["Elm","Segbeats","borrow","borrow_mut","change_max","change_min","clone","clone_into","count_changes","eq","equivalent","fmt","from","into","max_value","min_value","mul_u32","new","open","query_max","query_min","query_sum","range_add","to_owned","try_from","try_into","type_id","zero"],"q":[[0,"segbeats_task3"],[28,"core::clone"],[29,"core::ops::range"],[30,"core::cmp"],[31,"core::fmt"],[32,"core::fmt"],[33,"core::any"]],"d":["","","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","",""],"i":[0,0,1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,1,0,1,1,1,1,1,1,1,1,3],"f":[0,0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]],-2,-1],2,3,[4,[6,[5]]]],[[[1,[-1]],-2,-1],2,3,[4,[6,[5]]]],[[[1,[-1]]],[[1,[-1]]],4],[[-1,-2],2,[],[]],[[[1,[-1]],-2],7,3,[[6,[5]]]],[[[1,[-1]],[1,[-1]]],8,9],[[-1,-2],8,[],[]],[[[1,[-1]],10],11,3],[-1,-1,[]],[-1,-2,[],[]],[[],-1,[]],[[],-1,[]],[[-1,12],-1,[]],[[[13,[-1]]],[[1,[-1]]],3],[[5,-1],[[14,[5]]],[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[[[1,[-1]],-2],-1,3,[[6,[5]]]],[[[1,[-1]],-2,-1],2,3,[4,[6,[5]]]],[-1,-2,[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,16,[]],[[],-1,[]]],"c":[],"p":[[3,"Segbeats",0],[15,"tuple"],[8,"Elm",0],[8,"Clone",28],[15,"usize"],[8,"RangeBounds",29],[15,"u64"],[15,"bool"],[8,"PartialEq",30],[3,"Formatter",31],[6,"Result",31],[15,"u32"],[15,"slice"],[3,"Range",29],[4,"Result",32],[3,"TypeId",33]]},\
"segtree":{"doc":"Segment tree and its variants.","t":"DDDIDDDQLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLL","n":["Dense2dEntry","Dense2dSegtree","Entry","Op","Segtree","SegtreeWithCompression","Sparse2dSegtree","Value","apply","as_slice","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","collect_map","collect_map","collect_vec","deref","deref","deref_mut","deref_mut","drop","drop","entry","entry","entry","fmt","fmt","fmt","fmt","fmt","fold","fold","fold","fold","from","from","from","from","from","from","from_iter","from_iter","from_iter","from_len","identity","index","index","index","index","index","into","into","into","into","into","into","iter","iter","iter","iter","keys","max_right","min_left","mul","new","new","new","new","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id"],"q":[[0,"segtree"],[95,"core::cmp"],[96,"core::clone"],[97,"core::ops::function"],[98,"alloc::collections::btree::map"],[99,"alloc::vec"],[100,"core::fmt"],[101,"core::fmt"],[102,"core::iter::traits::collect"],[103,"core::slice::iter"],[104,"core::iter::traits::iterator"],[105,"core::result"],[106,"core::any"]],"d":["The result of <code>Dense2dSegtree::entry</code>.","A dense 2D segment tree.","The result of <code>Segtree::entry</code>.","A trait for segment tree operations.","A segment tree. Use <code>as_slice()</code> to debug.","A sparse (compressed) segment tree. Use <code>collect_map()</code> to …","A segment tree of segment trees (2D segment tree). The …","The value type.","Apply a function to $x_{k, l}$.","Returns a slice of $x_0, x_1, \\\\ldots, x_{n-1}$.","","","","","","","","","","","","","Collects the key-value pairs into a <code>BTreeMap</code>.","Collects the key-value pairs into a <code>BTreeMap</code>.","Collect to a $2$-dimensional vector.","","","","","","","Returns the entry of $x_i$.","Returns the entry of $x_k$. If $k$ is not found, it panics.","Returns the entry of $x_{i, j}$.","","","","","","Returns $x_l \\\\cdot x_{l+1} \\\\cdot \\\\ldots \\\\cdot x_{r-1}$.","Folds $\\\\left \\\\lbrace x_k \\\\mid k \\\\in \\\\text{{range}} \\\\right …","Folds $\\\\left \\\\lbrace x_{k, l} \\\\mid (k, l) \\\\in …","Fold $\\\\left \\\\lbrace x_{i, j} \\\\mid i \\\\in \\\\text{{range}}_i, …","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","Constructs a new segment tree with the specified length.","Returns the identity value $e$.","","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Returns an iterator of $x_0, x_1, \\\\ldots, x_{n-1}$.","Returns an iterator of $(k, x_k)$.","Returns the iterator of $(k, l, x_{k, l})$.","Returns an iterator that returns the rows $(x_{i, 0}, x_…","Returns the keys.","Returns the maximum $r$ s.t. $f(x _ l \\\\cdot \\\\dots \\\\cdot x …","Returns the minimum $l$ s.t. $f(x _ l \\\\cdot \\\\dots \\\\cdot x …","Multiplies two values: $x \\\\cdot y$.","Constructs with the specified values.","Constructs with the specified key-value pairs.","Constructs with the specified key-value pairs.","Constructs with the specified values.","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,0,5,1,7,7,13,9,1,11,14,7,13,9,1,11,14,9,1,11,13,14,13,14,13,14,7,9,11,7,13,9,1,11,7,9,1,11,7,13,9,1,11,14,7,9,1,7,5,7,9,1,1,11,7,13,9,1,11,14,7,9,1,11,9,7,7,5,7,9,1,11,7,13,9,1,11,14,7,13,9,1,11,14,7,13,9,1,11,14],"f":[0,0,0,0,0,0,0,0,[[[1,[-1,-2,-3]],-1,-2,-4],2,[3,4],[3,4],5,6],[[[7,[-1]]],8,5],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[9,[-1,-2]]],[[10,[-1]]],[4,3],5],[[[1,[-1,-2,-3]]],[[10,[[2,[-1,-2]]]]],[4,3,4],[4,3,4],5],[[[11,[-1]]],[[12,[12]]],5],[[[13,[-1]]],[],5],[[[14,[-1]]],[],5],[[[13,[-1]]],[],5],[[[14,[-1]]],[],5],[[[13,[-1]]],2,5],[[[14,[-1]]],2,5],[[[7,[-1]],15],[[13,[-1]]],5],[[[9,[-1,-2]],-1],[[13,[-2]]],3,5],[[[11,[-1]],15,15],[[14,[-1]]],5],[[[7,[-1]],16],17,5],[[[13,[-1]],16],17,5],[[[9,[-1,-2]],16],17,18,5],[[[1,[-1,-2,-3]],16],17,18,18,5],[[[11,[-1]],16],17,5],[[[7,[-1]],-2],[],5,[[19,[15]]]],[[[9,[-1,-2]],-3],[],3,5,[[19,[-1]]]],[[[1,[-1,-2,-3]],-4,-5],[],[3,4],[3,4],5,[[19,[-1]]],[[19,[-2]],4]],[[[11,[-1]],-2,-3],[],5,[[19,[15]]],[[19,[15]]]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,[[7,[-2]]],20,5],[-1,[[9,[-2,-3]]],20,[4,3],5],[-1,[[1,[-2,-3,-4]]],20,[3,4],[3,4],5],[15,[[7,[-1]]],5],[[]],[[[7,[-1]],15],[],5],[[[9,[-1,-2]],-1],[],3,5],[[[1,[-1,-2,-3]],-1],[],3,3,5],[[[1,[-1,-2,-3]],[2,[-1,-2]]],[],3,3,5],[[[11,[-1]],15],[],5],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[7,[-1]]],21,5],[[[9,[-1,-2]]],[[0,[22]]],3,5],[[[1,[-1,-2,-3]]],[[0,[22]]],[3,4],[3,4],5],[[[11,[-1]]],[[0,[22]]],5],[[[9,[-1,-2]]],[[8,[-1]]],3,5],[[[7,[-1]],15,-2],15,5,6],[[[7,[-1]],15,-2],15,5,6],[[]],[8,[[7,[-1]]],5],[[[8,[[2,[-1]]]]],[[9,[-1,-2]]],[4,3],5],[[[8,[[2,[-1,-2]]]]],[[1,[-1,-2,-3]]],[3,4],[3,4],5],[[[8,[12]]],[[11,[-1]]],5],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,[[23,[-2]]],[],[]],[-1,24,[]],[-1,24,[]],[-1,24,[]],[-1,24,[]],[-1,24,[]],[-1,24,[]]],"c":[],"p":[[3,"Sparse2dSegtree",0],[15,"tuple"],[8,"Ord",95],[8,"Clone",96],[8,"Op",0],[8,"FnMut",97],[3,"Segtree",0],[15,"slice"],[3,"SegtreeWithCompression",0],[3,"BTreeMap",98],[3,"Dense2dSegtree",0],[3,"Vec",99],[3,"Entry",0],[3,"Dense2dEntry",0],[15,"usize"],[3,"Formatter",100],[6,"Result",100],[8,"Debug",100],[8,"RangeBounds",101],[8,"IntoIterator",102],[3,"Iter",103],[8,"Iterator",104],[4,"Result",105],[3,"TypeId",106]]},\
"skew_heap":{"doc":"Meld のできるヒープ","t":"DLLLLLLLLLLLLLLLFLLLLLLLLLL","n":["SkewHeap","borrow","borrow_mut","clear","clone","clone_into","default","eq","extend","extend","fmt","from","from_iter","hash","into","into_sorted_vec","meld","meld","new","peek","pop","push","singleton","to_owned","try_from","try_into","type_id"],"q":[[0,"skew_heap"],[27,"core::cmp"],[28,"core::clone"],[29,"core::cmp"],[30,"core::iter::traits::collect"],[31,"core::fmt"],[32,"core::fmt"],[33,"core::hash"],[34,"core::option"],[35,"core::result"],[36,"core::any"]],"d":["Meld のできるヒープ","","","中身を殻にします。","","","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","ソート済みの <code>Vec</code> に変換します。","2 つの <code>SkewHeap</code> …","2 つの <code>SkewHeap</code> …","新しく構築します。","…","…","要素を一つ、追加します。","要素一つからなる <code>SkewHeap</code> を構築します。","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],"f":[0,[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],2,3],[[[1,[-1]]],[[1,[-1]]],4],[[-1,-2],2,[],[]],[[],[[1,[-1]]],3],[[[1,[-1]],[1,[-1]]],5,6],[[[1,[-1]],-2],2,[7,3],8],[[[1,[-1]],-2],2,3,8],[[[1,[-1]],9],10,[11,3]],[-1,-1,[]],[-1,[[1,[-2]]],8,3],[[[1,[-1]],-2],2,12,13],[-1,-2,[],[]],[[[1,[-1]]],[[14,[-1]]],3],[[[1,[-1]],[1,[-1]]],[[1,[-1]]],3],[[[1,[-1]],[1,[-1]]],2,3],[[],[[1,[-1]]],3],[[[1,[-1]]],[[15,[-1]]],3],[[[1,[-1]]],[[15,[-1]]],3],[[[1,[-1]],-1],2,3],[-1,[[1,[-1]]],3],[-1,-2,[],[]],[-1,[[16,[-2]]],[],[]],[-1,[[16,[-2]]],[],[]],[-1,17,[]]],"c":[],"p":[[3,"SkewHeap",0],[15,"tuple"],[8,"Ord",27],[8,"Clone",28],[15,"bool"],[8,"PartialEq",27],[8,"Copy",29],[8,"IntoIterator",30],[3,"Formatter",31],[6,"Result",31],[8,"Debug",31],[8,"Hash",32],[8,"Hasher",32],[3,"Vec",33],[4,"Option",34],[4,"Result",35],[3,"TypeId",36]]},\
"snippetter":{"doc":"","t":"HDDDHDLLLLLLLLLLLLLLLLMMMLLLLLLLFLLLLLLLLLLLLMFFLMMMLLLLLLLLLLLLLLLL","n":["CRATE_METADATAS","CrateMetadata","DescriptionSection","MetadataFile","PROJECT_ROOT","TagsSection","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","dependencies","description","description","deserialize","deserialize","deserialize","eq","eq","eq","eq","find_project_root_path","fmt","fmt","fmt","fmt","from","from","from","from","into","into","into","into","list","main","parse_local_dependencies_from_cargo_toml","serialize","short","tags","tags","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id"],"q":[[0,"snippetter"],[68,"core::result"],[69,"serde::de"],[70,"std::path"],[71,"core::fmt"],[72,"core::fmt"],[73,"alloc::vec"],[74,"serde::ser"],[75,"core::any"]],"d":["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,1,2,2,3,4,1,2,3,4,0,1,2,3,4,1,2,3,4,1,2,3,4,3,0,0,1,4,1,2,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4],"f":[0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[2,2],[3,3],[4,4],[[-1,-2],5,[],[]],[[-1,-2],5,[],[]],[[-1,-2],5,[],[]],[[-1,-2],5,[],[]],0,0,0,[-1,[[6,[2]]],7],[-1,[[6,[3]]],7],[-1,[[6,[4]]],7],[[1,1],8],[[2,2],8],[[3,3],8],[[4,4],8],[[],9],[[1,10],11],[[2,10],11],[[3,10],11],[[4,10],11],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],0,[[],5],[12,[[14,[13]]]],[[1,-1],6,15],0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,[[6,[-2]]],[],[]],[-1,16,[]],[-1,16,[]],[-1,16,[]],[-1,16,[]]],"c":[],"p":[[3,"CrateMetadata",0],[3,"MetadataFile",0],[3,"TagsSection",0],[3,"DescriptionSection",0],[15,"tuple"],[4,"Result",68],[8,"Deserializer",69],[15,"bool"],[3,"PathBuf",70],[3,"Formatter",71],[6,"Result",71],[15,"str"],[3,"String",72],[3,"Vec",73],[8,"Serializer",74],[3,"TypeId",75]]},\
"sparse_table":{"doc":"Sparse Table","t":"IDDQLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLL","n":["Op","SparseTable","SparseTable2d","Value","as_slice","as_slice","borrow","borrow","borrow_mut","borrow_mut","clone_from_slice","clone_from_slice","collect_vec","collect_vec","fmt","fmt","fold","fold","from","from","from","from","from","from","from_iter","get","index","inner","inner","into","into","iter","iter","mul","new","new","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"sparse_table"],[42,"alloc::vec"],[43,"core::fmt"],[44,"core::fmt"],[45,"core::ops::range"],[46,"core::iter::traits::collect"],[47,"core::iter::traits::iterator"],[48,"core::result"],[49,"core::any"]],"d":["A trait for the operation used in sparse tables.","A sparse table for 1-dimensional range queries.","A sparse table for 2-dimensional range queries.","The type of the values.","Returns a slice of the values.","Returns a slice of the values.","","","","","Constructs a sparse table from a slice of values.","Constructs a sparse table from a slice of values.","Collects the values into a vector.","Collects the values into a vector of vectors.","","","Returns $x_l \\\\cdot x_{l+1} \\\\cdot \\\\ldots \\\\cdot x_{r-1}$, or …","Returns $(x_{i_0, j_0} \\\\cdot \\\\dots \\\\cdot x_{i_1-1, j_0}) …","","Returns the argument unchanged.","","","","Returns the argument unchanged.","","Returns the value at the given index.","","Returns the inner table.","Returns the inner table.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Returns an iterator over the values.","Returns that yields the row of the table.","Multiplies two values: $x \\\\cdot y$.","Constructs a sparse table from a vector of values.","Constructs a sparse table from a vector of values.","","","","","",""],"i":[0,0,0,3,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,1,1,4,4,4,1,1,1,1,4,1,4,1,4,3,1,4,1,4,1,4,1,4],"f":[0,0,0,0,[[[1,[-1]]],2,3],[[[4,[-1]]],[[2,[5]]],3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[2,[[1,[-1]]],3],[[[2,[5]]],[[4,[-1]]],3],[[[1,[-1]]],5,3],[[[4,[-1]]],[[5,[5]]],3],[[[1,[-1]],6],7,3],[[[4,[-1]],6],7,3],[[[1,[-1]],-2],8,3,[[10,[9]]]],[[[4,[-1]],-2,-3],8,3,[[10,[9]]],[[10,[9]]]],[2,[[1,[-1]]],3],[-1,-1,[]],[5,[[1,[-1]]],3],[[[5,[5]]],[[4,[-1]]],3],[[[2,[5]]],[[4,[-1]]],3],[-1,-1,[]],[-1,[[1,[-2]]],11,3],[[[1,[-1]],9],[],3],[[[1,[-1]],9],[],3],[[[1,[-1]]],[[5,[5]]],3],[[[4,[-1]]],[[5,[[5,[[5,[5]]]]]]],3],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[0,[12]]],3],[[[4,[-1]]],[[0,[12]]],3],[[]],[5,[[1,[-1]]],3],[[[5,[5]]],[[4,[-1]]],3],[-1,[[13,[-2]]],[],[]],[-1,[[13,[-2]]],[],[]],[-1,[[13,[-2]]],[],[]],[-1,[[13,[-2]]],[],[]],[-1,14,[]],[-1,14,[]]],"c":[],"p":[[3,"SparseTable",0],[15,"slice"],[8,"Op",0],[3,"SparseTable2d",0],[3,"Vec",42],[3,"Formatter",43],[6,"Result",43],[4,"Option",44],[15,"usize"],[8,"RangeBounds",45],[8,"IntoIterator",46],[8,"Iterator",47],[4,"Result",48],[3,"TypeId",49]]},\
"splay_tree":{"doc":"スプレー木です。","t":"QQDDQIDDIDIQQLKLLKLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKKLLLKKLLLLLLLLLLLLLLLLLLLLL","n":["Acc","Acc","Entry","Iter","Lazy","LazyOps","NoLazy","Nop","Ops","SplayTree","Value","Value","Value","act","act_acc","act_acc","act_acc","act_value","act_value","act_value","append","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","cmp","compose","compose","compose","compose_to_option","default","delete","deref","deref_mut","drop","dump","entry","eq","equivalent","fmt","fold","from","from","from","from","from","from_iter","get","hash","index","insert","into","into","into","into","into","into_iter","into_iter","is_empty","iter","len","new","next","next_back","op","op","op","op","partial_cmp","proj","proj","proj","proj","range","reverse","split_off","to_owned","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id"],"q":[[0,"splay_tree"],[100,"core::ops::range"],[101,"core::cmp"],[102,"core::option"],[103,"core::fmt"],[104,"core::fmt"],[105,"core::hash"],[106,"core::result"],[107,"core::any"]],"d":["集約値型","集約値型","<code>SplayTree::entry</code> の戻り値型です。","<code>SplayTree::iter</code>, <code>SplayTree::range</code> の戻り値型です。","作用値型","集約と作用のトレイト","<code>Ops</code> を実装する型をラップして <code>LazyOps</code> …","集約も作用もなしの場合に使うトレイト","作用なしの場合に使うトレイト","スプレー木","<code>Sized</code>, <code>Debug</code>, <code>Clone</code> をまとめたトレイト","頂点重み型","頂点重み型","指定した範囲の要素すべてに作用します。","集約値への作用","","","頂点重みへの作用","","","…","","","","","","","","","","","","","","作用の合成","","","Option へ作用の合成","","指定した場所の要素を削除します。","","","","内部情報をダンプします。","…","","","","指定した範囲の要素を畳み込みます。","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","…","","","指定した場所に挿入します。","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","空ならば <code>true</code> を返します。","要素を順番に返すイテレータを返します。","要素数を返します。","空のスプレー木を構築します。","","","集約演算","集約演算","","","","集約化","集約化","","","…","指定した範囲の要素を逆順にします。","指定した場所以降を切り離して返します。","","","","","","","","","","","","","","","",""],"i":[17,3,0,0,3,0,0,0,0,0,0,17,3,1,3,18,19,3,18,19,1,18,19,1,14,8,18,19,1,14,8,1,1,1,3,18,19,3,1,1,8,8,1,1,1,1,1,1,1,18,19,1,14,8,1,1,1,1,1,18,19,1,14,8,1,14,1,1,1,1,14,14,17,3,18,19,1,17,3,18,19,1,1,1,1,18,19,1,14,8,18,19,1,14,8,18,19,1,14,8],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,[[[1,[-1]],-2],2,3,[[5,[4]]]],[[],2],[[],2],[[],2],[[],2],[[],2],[[],2],[[[1,[-1]],[1,[-1]]],2,3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],3],[[-1,-2],2,[],[]],[[[1,[-1]],[1,[-1]]],6,3],[[],2],[[],2],[[],2],[7,2],[[],[[1,[-1]]],3],[[[1,[-1]],4],[],3],[[[8,[-1]]],[],3],[[[8,[-1]]],[],3],[[[1,[-1]]],2,3],[[[1,[-1]]],2,3],[[[1,[-1]],4],[[7,[[8,[-1]]]]],3],[[[1,[-1]],[1,[-1]]],9,3],[[-1,-2],9,[],[]],[[[1,[-1]],10],11,3],[[[1,[-1]],-2],7,3,[[5,[4]]]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,[[1,[-2]]],12,3],[[[1,[-1]],4],7,3],[[[1,[-1]],-2],2,3,13],[[[1,[-1]],4],[],3],[[[1,[-1]],4],2,3],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[],3],[-1,-2,[],[]],[[[1,[-1]]],9,3],[[[1,[-1]]],[[14,[-1]]],3],[[[1,[-1]]],4,3],[[],[[1,[-1]]],3],[[[14,[-1]]],7,3],[[[14,[-1]]],7,3],[[]],[[]],[[]],[[]],[[[1,[-1]],[1,[-1]]],[[7,[6]]],3],[[]],[[]],[[]],[[]],[[[1,[-1]],-2],[[14,[-1]]],3,[[5,[4]]]],[[[1,[-1]],-2],2,3,[[5,[4]]]],[[[1,[-1]],4],[[1,[-1]]],3],[-1,-2,[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,[[15,[-2]]],[],[]],[-1,16,[]],[-1,16,[]],[-1,16,[]],[-1,16,[]],[-1,16,[]]],"c":[],"p":[[3,"SplayTree",0],[15,"tuple"],[8,"LazyOps",0],[15,"usize"],[8,"RangeBounds",100],[4,"Ordering",101],[4,"Option",102],[3,"Entry",0],[15,"bool"],[3,"Formatter",103],[6,"Result",103],[8,"IntoIterator",104],[8,"Hasher",105],[3,"Iter",0],[4,"Result",106],[3,"TypeId",107],[8,"Ops",0],[3,"Nop",0],[3,"NoLazy",0]]},\
"suffix_array":{"doc":"Suffix Array を計算します。","t":"FF","n":["lcp_array","suffix_array"],"q":[[0,"suffix_array"],[2,"alloc::vec"],[3,"core::cmp"]],"d":["LCP 配列を計算します。","Surrix Array を計算します。"],"i":[0,0],"f":[[[[1,[-1]],[1,[2]]],[[3,[2]]],4],[[[1,[-1]]],[[3,[2]]],4]],"c":[],"p":[[15,"slice"],[15,"usize"],[3,"Vec",2],[8,"Ord",3]]},\
"swag":{"doc":"Sliding Window Aggregation (SWAG)","t":"DIQLLLLLLLLLLLLLLLLLLLLLLKLLLLLLL","n":["DequeueSwag","Op","Value","as_two_slices","borrow","borrow_mut","clone_from_slice","collect_vec","copy_from_slice","default","extend","fmt","fold","from","from","from_iter","get","index","into","into_iter","into_iter","is_empty","iter","len","new","op","pop_back","pop_front","push_back","push_front","try_from","try_into","type_id"],"q":[[0,"swag"],[33,"alloc::vec"],[34,"core::iter::traits::collect"],[35,"core::fmt"],[36,"core::fmt"],[37,"core::iter::traits::iterator"],[38,"core::result"],[39,"core::any"]],"d":["DequeueSwag","Operations","Value type","Returns two slices, joining that is exactly the all …","","","Constructs a new <code>DequeueSwag</code> from a slice.","Collects the <code>DequeueSwag</code> into a <code>Vec</code>.","Constructs a new <code>DequeueSwag</code> from a slice.","","","","Fold the <code>DequeueSwag</code>. Returns <code>None</code> if the <code>DequeueSwag</code> is …","","Returns the argument unchanged.","","Returns the element at the index.","","Calls <code>U::from(self)</code>.","","","Returns whether the <code>DequeueSwag</code> is empty.","Returns an iterator over the <code>DequeueSwag</code>.","Returns the length of the <code>DequeueSwag</code>.","Constructs a new <code>DequeueSwag</code>.","Associative operation","Pop an element from the back. Returns <code>None</code> if the …","Pop an element from the front. Returns <code>None</code> if the …","Append an element to the back.","Append an element to the front.","","",""],"i":[0,0,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1],"f":[0,0,0,[[[1,[-1]]],[[3,[2,2]]],4],[-1,-2,[],[]],[-1,-2,[],[]],[2,[[1,[-1]]],4],[[[1,[-1]]],5,4],[2,[[1,[-1]]],4],[[],[[1,[-1]]],4],[[[1,[-1]],-2],3,4,6],[[[1,[-1]],7],8,4],[[[1,[-1]]],9,4],[5,[[1,[-1]]],4],[-1,-1,[]],[-1,[[1,[-2]]],6,4],[[[1,[-1]],10],9,4],[[[1,[-1]],10],[],4],[-1,-2,[],[]],[[[1,[-1]]],[],4],[[[1,[-1]]],[],4],[[[1,[-1]]],11,4],[[[1,[-1]]],[[0,[12]]],4],[[[1,[-1]]],10,4],[[],[[1,[-1]]],4],[[]],[[[1,[-1]]],9,4],[[[1,[-1]]],9,4],[[[1,[-1]]],3,4],[[[1,[-1]]],3,4],[-1,[[13,[-2]]],[],[]],[-1,[[13,[-2]]],[],[]],[-1,14,[]]],"c":[],"p":[[3,"DequeueSwag",0],[15,"slice"],[15,"tuple"],[8,"Op",0],[3,"Vec",33],[8,"IntoIterator",34],[3,"Formatter",35],[6,"Result",35],[4,"Option",36],[15,"usize"],[15,"bool"],[8,"Iterator",37],[4,"Result",38],[3,"TypeId",39]]},\
"tree_fold":{"doc":"2-way tree DP","t":"IDQLLMLKLMKLLFLLKM","n":["Op","TwoWayTreeFoldResult","Value","borrow","borrow_mut","branch","from","identity","into","lower","mul","try_from","try_into","two_way_tree_fold","two_way_tree_fold","type_id","up","upper"],"q":[[0,"tree_fold"],[18,"core::result"],[19,"alloc::vec"],[20,"core::any"]],"d":["Operations","The return value of <code>Op::two_way_tree_fold()</code> ans …","A monoid $M$.","","","$f(\\\\phi(T_i^\\\\blacktriangledown))$","Returns the argument unchanged.","$* \\\\to F$: empty forest","Calls <code>U::from(self)</code>.","$\\\\prod_{j \\\\lessdot i} f(\\\\phi(T_j^\\\\blacktriangledown))$","$F \\\\times F \\\\to F$: concatenate two forests","","","Performs 2-way tree DP","Performs 2-way tree DP","","$F \\\\times V \\\\to T \\\\to F$: join by a root","$f(\\\\phi(T_i^\\\\triangle))$"],"i":[0,0,6,5,5,5,5,6,5,5,6,5,5,0,6,5,6,5],"f":[0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],0,[-1,-1,[]],[-1,[],[]],[-1,-2,[],[]],0,[-1,[],[]],[-1,[[1,[-2]]],[],[]],[-1,[[1,[-2]]],[],[]],[[-1,[4,[[3,[2]]]],[4,[2]]],5,6],[[-1,[4,[[3,[2]]]],[4,[2]]],5,[]],[-1,7,[]],[[-1,2],[],[]],0],"c":[],"p":[[4,"Result",18],[15,"usize"],[3,"Vec",19],[15,"slice"],[3,"TwoWayTreeFoldResult",0],[8,"Op",0],[3,"TypeId",20]]},\
"trial":{"doc":"Execute the trial-division algorithm.","t":"DDDILLLLLLLFFLLLKLLLLLLLLLKFFLLLLLLLLLK","n":["Divisors","PrimeFactors","PrimeFactorsRle","Value","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","divides","divisors","divisors_unordered","from","from","from","increment","into","into","into","into_iter","into_iter","into_iter","next","next","next","one","prime_factors","prime_factors_rle","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","zero"],"q":[[0,"trial"],[39,"alloc::vec"],[40,"core::option"],[41,"core::result"],[42,"core::any"]],"d":["See the document of a function <code>divisors_unordered</code>","See the document of a function <code>prime_factors</code>","See the document of a function <code>prime_factors_rle</code>","Abstraction of unsigned integers.","","","","","","","Returns <code>true</code> if and only if <code>self</code> divides <code>n</code>.","Returns a <code>Vec</code> of the divisors. The divisors is guaranteed …","Takes an unsigned integer and returns an iterator to yield …","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Increment <code>self</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","Returns <code>1</code>.","Takes an unsigned integer and returns an iterator to yield …","Takes an unsigned integer and returns an iterator to yield …","","","","","","","","","","Returns <code>0</code>."],"i":[0,0,0,0,4,7,8,4,7,8,3,0,0,4,7,8,3,4,7,8,4,7,8,4,7,8,3,0,0,4,7,8,4,7,8,4,7,8,3],"f":[0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[-1,-1],1,[]],[-1,[[2,[-1]]],3],[-1,[[4,[-1]]],3],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,5,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[4,[-1]]],6,3],[[[7,[-1]]],6,3],[[[8,[-1]]],6,3],[[],-1,[]],[-1,[[8,[-1]]],3],[-1,[[7,[-1]]],3],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,[[9,[-2]]],[],[]],[-1,10,[]],[-1,10,[]],[-1,10,[]],[[],-1,[]]],"c":[],"p":[[15,"bool"],[3,"Vec",39],[8,"Value",0],[3,"Divisors",0],[15,"tuple"],[4,"Option",40],[3,"PrimeFactorsRle",0],[3,"PrimeFactors",0],[4,"Result",41],[3,"TypeId",42]]},\
"trie":{"doc":"A set and map data structure on trie.","t":"RDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["DEGREE","TrieMap","TrieSet","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","contains","default","default","eq","eq","fmt","fmt","for_each","for_each_kv","for_each_prefix","for_each_prefix","from","from","get","get_mut","get_or_insert","get_or_insert_with","insert","insert","into","into","new","new","remove","remove","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"trie"],[44,"core::clone"],[45,"core::iter::traits::collect"],[46,"core::cmp"],[47,"core::fmt"],[48,"core::fmt"],[49,"core::option"],[50,"core::ops::function"],[51,"core::any"]],"d":["Tries here have the fixed branching number 26.","A map base on a trie.","A set base on a trie.","","","","","","","","","Returns <code>true</code> if the set contains a value.","","","","","","","Visits all the values of a values in the trie, in …","Visits all the pairs of a key of a values in the trie, in …","Visits all the “existing” nodes corresponding to the …","Visits all the “existing” nodes corresponding to the …","Returns the argument unchanged.","Returns the argument unchanged.","Returns a reference to the value corresponding to the key.","Returns a mutable reference to the value corresponding to …","Inserts a <code>value</code> at <code>key</code> if it is <code>None</code>, then returns a …","Inserts a value computed from <code>f</code> at <code>key</code> if it is <code>None</code>, then …","Inserts a key-value pair into the map.","Adds a value to the set.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Makes a new empty TrieMap.","Makes a new empty TrieMap.","Removes a key from the map, returning the stored key and …","Removes a value from the set. Returns whether the value was","","","","","","","",""],"i":[0,0,0,1,3,1,3,1,3,1,3,3,1,3,1,3,1,3,3,1,1,3,1,3,1,1,1,1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3],"f":[0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[1,[-1]]],2],[3,3],[[-1,-2],4,[],[]],[[-1,-2],4,[],[]],[[3,-1],5,6],[[],[[1,[-1]]],[]],[[],3],[[[1,[-1]],[1,[-1]]],5,7],[[3,3],5],[[[1,[-1]],8],9,10],[[3,8],9],[[3,-1],4,11],[[[1,[-1]],-2],4,[],11],[[[1,[-1]],-2,-3],4,[],6,11],[[3,-1,-2],4,6,11],[-1,-1,[]],[-1,-1,[]],[[[1,[-1]],-2],[[12,[-1]]],[],6],[[[1,[-1]],-2],[[12,[-1]]],[],6],[[[1,[-1]],-2,-1],-1,[],6],[[[1,[-1]],-2,-3],-1,[],6,13],[[[1,[-1]],-2,-1],[[12,[-1]]],[],6],[[3,-1],5,6],[-1,-2,[],[]],[-1,-2,[],[]],[[],[[1,[-1]]],[]],[[],3],[[[1,[-1]],-2],[[12,[-1]]],[],6],[[3,-1],5,6],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,15,[]],[-1,15,[]]],"c":[],"p":[[3,"TrieMap",0],[8,"Clone",44],[3,"TrieSet",0],[15,"tuple"],[15,"bool"],[8,"IntoIterator",45],[8,"PartialEq",46],[3,"Formatter",47],[6,"Result",47],[8,"Debug",47],[8,"FnMut",48],[4,"Option",49],[8,"FnOnce",48],[4,"Result",50],[3,"TypeId",51]]},\
"uf_checklist":{"doc":"Union-find …","t":"DDLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["Iter","UfChecklist","borrow","borrow","borrow_mut","borrow_mut","check","clone","clone_into","fmt","fmt","from","from","into","into","into_iter","is_checked","lower_bound","new","next","range_check","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"uf_checklist"],[28,"core::fmt"],[29,"core::fmt"],[30,"core::ops::range"],[31,"core::result"],[32,"core::any"]],"d":["<code>UfChecklist::range_check</code> が返すイテレータです。","…","","","","","指定した場所をチェックします。","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","指定した場所がチェック済みならば <code>true</code> …","…","区間 [0, n[ …","","区間 <code>range</code> …","","","","","","",""],"i":[0,0,1,7,1,7,1,1,1,1,7,1,7,1,7,7,1,1,1,7,1,1,1,7,1,7,1,7],"f":[0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[1,2],3],[1,1],[[-1,-2],4,[],[]],[[1,5],6],[[7,5],6],[-1,-1,[]],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[1,2],3],[[1,2],[[8,[2]]]],[2,1],[7,8],[[1,-1],7,[[9,[2]]]],[-1,-2,[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,[[10,[-2]]],[],[]],[-1,11,[]],[-1,11,[]]],"c":[],"p":[[3,"UfChecklist",0],[15,"usize"],[15,"bool"],[15,"tuple"],[3,"Formatter",28],[6,"Result",28],[3,"Iter",0],[4,"Option",29],[8,"RangeBounds",30],[4,"Result",31],[3,"TypeId",32]]},\
"union_find":{"doc":"Union Find です。","t":"EEIDQEKLLLLLLLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLL","n":["EdgeCount","HasCycle","Op","UnionFind","Value","VertexCount","add_edge","add_edge","add_edge","add_edge","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","default","eq","find","find_mut","fmt","from","from","from","from","from_values","get_value","graft","graft","graft","graft","hash","into","into","into","into","is_root","new","same","singleton","singleton","singleton","singleton","to_owned","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","union","value","value_mut"],"q":[[0,"union_find"],[63,"core::clone"],[64,"core::default"],[65,"core::cmp"],[66,"core::fmt"],[67,"core::fmt"],[68,"core::hash"],[69,"core::hash"],[70,"core::any"]],"d":["辺の本数","サイクルがあるとき、<code>true</code>","…","","頂点重み型","頂点の個数","連結成分に辺を１本追加したとき","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","…","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","<code>UnionFind::new()</code> で構築したときのデフォルト値","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,4,0,4,16,17,18,16,17,18,2,16,17,18,2,2,2,2,2,2,2,2,16,17,18,2,2,2,4,16,17,18,2,16,17,18,2,2,2,2,4,16,17,18,2,16,17,18,2,16,17,18,2,16,17,18,2,2,2,2],"f":[0,0,0,0,0,0,[[],1],[[],1],[[],1],[[],1],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[2,[-1]]],[[2,[-1]]],[3,4]],[[-1,-2],1,[],[]],[[],[[2,[-1]]],[5,4]],[[[2,[-1]],[2,[-1]]],6,[7,4]],[[[2,[-1]],8],8,4],[[[2,[-1]],8],8,4],[[[2,[-1]],9],10,4],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[11,[[2,[-1]]],4],[[[2,[-1]],8],[],4],[[],1],[[],1],[[],1],[[],1],[[[2,[-1]],-2],1,[12,4],13],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[2,[-1]],8],6,4],[8,[[2,[-1]]],4],[[[2,[-1]],8,8],6,4],[[]],[[]],[[]],[[]],[-1,-2,[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,[[14,[-2]]],[],[]],[-1,15,[]],[-1,15,[]],[-1,15,[]],[-1,15,[]],[[[2,[-1]],8,8],6,4],[[[2,[-1]],8],[],4],[[[2,[-1]],8],[],4]],"c":[],"p":[[15,"tuple"],[3,"UnionFind",0],[8,"Clone",63],[8,"Op",0],[8,"Default",64],[15,"bool"],[8,"PartialEq",65],[15,"usize"],[3,"Formatter",66],[6,"Result",66],[3,"Vec",67],[8,"Hash",68],[8,"Hasher",68],[4,"Result",69],[3,"TypeId",70],[4,"EdgeCount",0],[4,"VertexCount",0],[4,"HasCycle",0]]},\
"veb":{"doc":"A predecessor data structure based on van Emde Boas trees.","t":"NNDELLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMM","n":["Internal","Leaf","VebMap","VebSet","borrow","borrow","borrow_mut","borrow_mut","collect","collect","contains","contains_key","fmt","fmt","from","from","from_iter","from_iter","get","get_mut","index","index_mut","insert","insert","into","into","is_empty","is_empty","len","len","max","max","max_key","max_value","min","min","min_key","min_value","new","new","pred","pred","pred_eq","pred_eq","pred_eq_key","pred_eq_value","pred_key","pred_value","remove","remove","succ","succ","succ_eq","succ_eq_key","succ_eq_value","succ_key","succ_value","try_from","try_from","try_into","try_into","type_id","type_id","chunks","csize","len","max","min","summary"],"q":[[0,"veb"],[63,"veb::VebSet"],[69,"alloc::vec"],[70,"core::fmt"],[71,"core::fmt"],[72,"core::option"],[73,"core::result"],[74,"core::any"]],"d":["","","A van Emde Boas tree-based map. The map is implemented as …","A van Emde Boas tree.","","","","","Returns the elements in the map in ascending order. The …","Returns the elements in the set in ascending order. The …","Returns <code>true</code> if the set contains the given element. …","Returns <code>true</code> if the map contains the given key.","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Returns the value corresponding to the key.","Returns a mutable reference to the value corresponding to …","","","Inserts an element into the map. Returns the previous …","Inserts an element into the set. Returns <code>true</code> if the …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Returns <code>true</code> if the map is empty.","Returns <code>true</code> if the set is empty. Returns <code>false</code> if the set …","Returns $|S|$.","Returns the number of elements in the set.","Returns the entry at $\\\\max \\\\left( S \\\\right)$.","Returns the maximum element in the set. Returns <code>None</code> if …","Returns the key $\\\\max \\\\left( S \\\\right)$.","Returns the value at $\\\\max \\\\left( S \\\\right)$.","Returns the entry at $\\\\min \\\\left( S \\\\right)$.","Returns the minimum element in the set. Returns <code>None</code> if …","Returns the key $\\\\min \\\\left( S \\\\right)$.","Returns the value at $\\\\min \\\\left( S \\\\right)$.","Creates a new van Emde Boas tree-based map with the given …","Creates a new van Emde Boas tree with the given capacity.","Returns the entry at $\\\\max \\\\left (i^▽ \\\\right)$.","Returns $\\\\min{j \\\\in S \\\\mid j \\\\le i}$.","Returns the entry at $\\\\max \\\\left (i^▲ \\\\right)$.","Returns $\\\\max{j \\\\in S \\\\mid j \\\\leq i}$.","Returns the key $\\\\max \\\\left (i^▲ \\\\right)$.","Returns the value at $\\\\max \\\\left (i^▲ \\\\right)$.","Returns the key $\\\\max \\\\left (i^▽ \\\\right)$.","Returns the value at $\\\\max \\\\left (i^▽ \\\\right)$.","Returns the value at $i$.","Removes an element from the set. Returns <code>true</code> if the …","Returns the entry at $\\\\min \\\\left (i^△ \\\\right)$.","Returns the minimum element greater than given element. …","Returns the entry at $\\\\min \\\\left (i^▲ \\\\right)$.","Returns the key $\\\\min \\\\left (i^▲ \\\\right)$.","Returns the value at $\\\\min \\\\left (i^▲ \\\\right)$.","Returns the key $\\\\min \\\\left (i^△ \\\\right)$.","Returns the value at $\\\\min \\\\left (i^△ \\\\right)$.","","","","","","","","","","","",""],"i":[5,5,0,0,1,5,1,5,1,5,5,1,1,5,1,5,1,5,1,1,1,1,1,5,1,5,1,5,1,5,1,5,1,1,1,5,1,1,1,5,1,5,1,5,1,1,1,1,1,5,1,5,1,1,1,1,1,1,5,1,5,1,5,14,14,14,14,14,14],"f":[0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],[[4,[[3,[2,-1]]]]],[]],[5,[[4,[2]]]],[[5,2],6],[[[1,[-1]],2],6,[]],[[[1,[-1]],7],8,9],[[5,7],8],[-1,-1,[]],[-1,-1,[]],[-1,[[1,[-2]]],10,[]],[-1,5,10],[[[1,[-1]],2],[[11,[-1]]],[]],[[[1,[-1]],2],[[11,[-1]]],[]],[[[1,[-1]],2],-1,[]],[[[1,[-1]],2],-1,[]],[[[1,[-1]],2,-1],[[11,[-1]]],[]],[[5,2],6],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1]]],6,[]],[5,6],[[[1,[-1]]],2,[]],[5,2],[[[1,[-1]]],[[11,[[3,[2,-1]]]]],[]],[5,[[11,[2]]]],[[[1,[-1]]],[[11,[2]]],[]],[[[1,[-1]]],[[11,[-1]]],[]],[[[1,[-1]]],[[11,[[3,[2,-1]]]]],[]],[5,[[11,[2]]]],[[[1,[-1]]],[[11,[2]]],[]],[[[1,[-1]]],[[11,[-1]]],[]],[2,[[1,[-1]]],[]],[2,5],[[[1,[-1]],2],[[11,[[3,[2,-1]]]]],[]],[[5,2],[[11,[2]]]],[[[1,[-1]],2],[[11,[[3,[2,-1]]]]],[]],[[5,2],[[11,[2]]]],[[[1,[-1]],2],[[11,[2]]],[]],[[[1,[-1]],2],[[11,[-1]]],[]],[[[1,[-1]],2],[[11,[2]]],[]],[[[1,[-1]],2],[[11,[-1]]],[]],[[[1,[-1]],2],[[11,[-1]]],[]],[[5,2],6],[[[1,[-1]],2],[[11,[[3,[2,-1]]]]],[]],[[5,2],[[11,[2]]]],[[[1,[-1]],2],[[11,[[3,[2,-1]]]]],[]],[[[1,[-1]],2],[[11,[2]]],[]],[[[1,[-1]],2],[[11,[-1]]],[]],[[[1,[-1]],2],[[11,[2]]],[]],[[[1,[-1]],2],[[11,[-1]]],[]],[-1,[[12,[-2]]],[],[]],[-1,[[12,[-2]]],[],[]],[-1,[[12,[-2]]],[],[]],[-1,[[12,[-2]]],[],[]],[-1,13,[]],[-1,13,[]],0,0,0,0,0,0],"c":[],"p":[[3,"VebMap",0],[15,"usize"],[15,"tuple"],[3,"Vec",69],[4,"VebSet",0],[15,"bool"],[3,"Formatter",70],[6,"Result",70],[8,"Debug",70],[8,"IntoIterator",71],[4,"Option",72],[4,"Result",73],[3,"TypeId",74],[13,"Internal",63]]},\
"vec_lines":{"doc":"傾き単調な直線の列を <code>Vec</code> で管理します。","t":"IEEDIDGGLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLKLLLLLLLLLLLLLLLLLL","n":["Constraint","DecreasingTilt","IncreasingTilt","Line","Signed","VecLines","VecLinesDecreasing","VecLinesIncreasing","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","default","default","eq","eq","eq","eq","equivalent","equivalent","equivalent","equivalent","eval","eval_gcc","fmt","fmt","fmt","fmt","from","from","from","from","get","hash","hash","hash","hash","into","into","into","into","into_coeff","is_empty","iter_copied","len","new","ok","ok","ok","push","strictly_better","strictly_better","strictly_better","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id"],"q":[[0,"vec_lines"],[81,"core::clone"],[82,"core::default"],[83,"core::cmp"],[84,"core::option"],[85,"core::fmt"],[86,"core::fmt"],[87,"core::hash"],[88,"core::result"],[89,"core::any"]],"d":["…","傾き単調減少を意味するマーカー","傾き単調増加を意味するマーカー","一次関数 $ax + b$ を、<code>[a, b]</code> …","符号つき整数","傾き単調な直線の列を <code>Vec</code> で管理します。","傾きが単調減少な直線の列を管理します。","傾きが単調増加な直線の列を管理します。","","","","","","","","","","","","","","","","","","","","","","","","","","","特定の x 座標における値を計算します。","黄金分割探索で最適値を計算します。","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","index 番目の直線を返します。","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","係数を返します。","管理している直線が 0 本のとき <code>true</code>…","…","管理している直線の本数を返します。","傾き単調な直線の列を <code>Vec</code> で管理します。","","","","後ろに直線を挿入します。","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,0,0,1,3,4,5,1,3,4,5,1,3,4,5,1,3,4,5,1,3,1,3,4,5,1,3,4,5,3,1,1,3,4,5,1,3,4,5,1,1,3,4,5,1,3,4,5,3,1,1,1,1,8,4,5,1,8,4,5,1,3,4,5,1,3,4,5,1,3,4,5,1,3,4,5],"f":[0,0,0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[1,[-1,-2]]],[[1,[-1,-2]]],2,2],[[[3,[-1]]],[[3,[-1]]],2],[4,4],[5,5],[[-1,-2],6,[],[]],[[-1,-2],6,[],[]],[[-1,-2],6,[],[]],[[-1,-2],6,[],[]],[[],[[1,[-1,-2]]],7,8],[[],[[3,[-1]]],9],[[[1,[-1,-2]],[1,[-1,-2]]],10,11,11],[[[3,[-1]],[3,[-1]]],10,11],[[4,4],10],[[5,5],10],[[-1,-2],10,[],[]],[[-1,-2],10,[],[]],[[-1,-2],10,[],[]],[[-1,-2],10,[],[]],[[[3,[-1]],-1],-1,7],[[[1,[-1,-2]],-1],[[12,[-1]]],7,8],[[[1,[-1,-2]],13],14,15,15],[[[3,[-1]],13],14,15],[[4,13],14],[[5,13],14],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[[[1,[-1,-2]],16],[[12,[[3,[-1]]]]],7,8],[[[1,[-1,-2]],-3],6,17,17,18],[[[3,[-1]],-2],6,17,18],[[4,-1],6,18],[[5,-1],6,18],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[[3,[-1]]],[[19,[-1]]],7],[[[1,[-1,-2]]],10,7,8],[[[1,[-1,-2]]],[[0,[20]]],7,8],[[[1,[-1,-2]]],16,7,8],[[],[[1,[-1,-2]]],7,8],[[[3,[-1]],[3,[-1]]],10,7],[[[3,[-1]],[3,[-1]]],10,7],[[[3,[-1]],[3,[-1]]],10,7],[[[1,[-1,-2]],[19,[-1]]],6,7,8],[[-1,-1],10,7],[[-1,-1],10,7],[[-1,-1],10,7],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,[[21,[-2]]],[],[]],[-1,22,[]],[-1,22,[]],[-1,22,[]],[-1,22,[]]],"c":[],"p":[[3,"VecLines",0],[8,"Clone",81],[3,"Line",0],[4,"DecreasingTilt",0],[4,"IncreasingTilt",0],[15,"tuple"],[8,"Signed",0],[8,"Constraint",0],[8,"Default",82],[15,"bool"],[8,"PartialEq",83],[4,"Option",84],[3,"Formatter",85],[6,"Result",85],[8,"Debug",85],[15,"usize"],[8,"Hash",86],[8,"Hasher",86],[15,"array"],[8,"Iterator",87],[4,"Result",88],[3,"TypeId",89]]},\
"wavelet_matrix":{"doc":"ウェーブレット行列","t":"DDDDLLLLLLLLLLLLLLLLLLLLMLLLLLLLLLLLLLLLLLLLLLLLLMLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLM","n":["SpanInNode","Spans","StaticBitVec","WaveletMatrix","access","access","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","default","default","depth","eq","eq","eq","eq","equivalent","equivalent","equivalent","equivalent","fmt","fmt","fmt","fmt","from","from","from","from","from_iter","from_iter","from_iter_collect_vec2","from_slice_of_usize_mut","hash","hash","hash","hash","index","into","into","into","into","into_iter","is_empty","is_empty","len","len","next","next_value","prev_value","quantile","range_freq","rank","select","spans","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","value"],"q":[[0,"wavelet_matrix"],[84,"core::fmt"],[85,"core::fmt"],[86,"alloc::vec"],[87,"core::ops::function"],[88,"core::hash"],[89,"core::option"],[90,"core::ops::range"],[91,"core::result"],[92,"core::any"]],"d":["<code>Spans</code> のアイテム型です。詳しくは …","イテレータです 詳しくは <code>WaveletMatrix::spans</code> …","累積和のできる静的なビットベクター","ウェーブレット行列","<code>i</code> 番目の要素を返します。","<code>a[i]</code>","","","","","","","","","","","","","","","","","","","ウェーブレット行列内の <code>i</code> 座標","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","…","特に高速化の意図がなければ、<code>FromIterator</code> …","","","","","ウェーブレット行列内の <code>j</code> 座標の範囲","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","配列が空であれば <code>true</code> を返します。","<code>a.is_empty()</code>","配列の長さを返します。","<code>a.len()</code>","","<code>index</code> により指定された部分列のうち、 <code>value</code> …","<code>index</code> により指定された部分列のうち、 <code>value</code> …","<code>index</code> により指定された部分列のうち、 <code>value</code> …","<code>index</code> により指定された部分列のうち、 <code>value</code> …","<code>sum(a[..end])</code>","min i s.t. <code>target &lt;= sum(a[..i])</code>","対応する部分を、<code>(depth, index_range, value_range)</code> …","","","","","","","","","","","","","","","","","現在のノードの担当する値の範囲"],"i":[0,0,0,0,1,3,1,3,5,6,1,3,5,6,1,3,5,6,1,3,5,6,1,3,6,1,3,5,6,1,3,5,6,1,3,5,6,1,3,5,6,1,3,1,1,1,3,5,6,6,1,3,5,6,5,1,3,1,3,5,1,1,1,1,3,3,1,1,3,5,6,1,3,5,6,1,3,5,6,1,3,5,6,6],"f":[0,0,0,0,[[1,2],2],[[3,2],4],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,1],[3,3],[5,5],[6,6],[[-1,-2],7,[],[]],[[-1,-2],7,[],[]],[[-1,-2],7,[],[]],[[-1,-2],7,[],[]],[[],1],[[],3],0,[[1,1],4],[[3,3],4],[[5,5],4],[[6,6],4],[[-1,-2],4,[],[]],[[-1,-2],4,[],[]],[[-1,-2],4,[],[]],[[-1,-2],4,[],[]],[[1,8],9],[[3,8],9],[[5,8],9],[[6,8],9],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[-1,1,10],[-1,3,10],[-1,[[7,[1,[11,[[11,[2]]]]]]],10],[[[12,[2]],-1],1,13],[[1,-1],7,14],[[3,-1],7,14],[[5,-1],7,14],[[6,-1],7,14],0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[1,4],[3,4],[1,2],[3,2],[5,15],[[1,-1,-2],[[15,[2]]],[[16,[2]]],[[16,[2]]]],[[1,-1,-2],[[15,[2]]],[[16,[2]]],[[16,[2]]]],[[1,2,-1,-2],[[15,[2]]],[[16,[2]]],[[16,[2]]]],[[1,-1,-2],2,[[16,[2]]],[[16,[2]]]],[[3,2],2],[[3,2],2],[[1,-1,-2],5,[[16,[2]]],[[16,[2]]]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,[[17,[-2]]],[],[]],[-1,18,[]],[-1,18,[]],[-1,18,[]],[-1,18,[]],0],"c":[],"p":[[3,"WaveletMatrix",0],[15,"usize"],[3,"StaticBitVec",0],[15,"bool"],[3,"Spans",0],[3,"SpanInNode",0],[15,"tuple"],[3,"Formatter",84],[6,"Result",84],[8,"IntoIterator",85],[3,"Vec",86],[15,"slice"],[8,"FnMut",87],[8,"Hasher",88],[4,"Option",89],[8,"RangeBounds",90],[4,"Result",91],[3,"TypeId",92]]},\
"z_algo":{"doc":"","t":"F","n":["z_algo"],"q":[[0,"z_algo"],[1,"alloc::vec"],[2,"core::cmp"]],"d":["Z-algorithm"],"i":[0],"f":[[[[1,[-1]]],[[3,[2]]],4]],"c":[],"p":[[15,"slice"],[15,"usize"],[3,"Vec",1],[8,"Eq",2]]},\
"zeta":{"doc":"…","t":"FFFFFFFFFFFFFFFFFF","n":["add","add_inv","add_rinv","aggr","bitand","bitor","bitxor","for_each","max","min","radd","rbitand","rbitor","rbitxor","rmax","rmin","rzeta","zeta"],"q":[[0,"zeta"],[18,"core::marker"],[19,"core::ops::arith"],[20,"core::ops::arith"],[21,"core::ops::function"],[22,"core::ops::bit"],[23,"core::ops::bit"]],"d":["+ でゼータ変換","(+, -) でメビウス変換","反転束において (+, -) でメビウス変換","すべての添字集合に関して (二項演算 f, …","bit-and でゼータ変換","bit-or でゼータ変換","bit-xor でゼータ変換","…","max でゼータ変換","min でゼータ変換","反転束において + でゼータ変換","反転束において bit-and でメビウス変換","反転束において bit-or でメビウス変換","反転束において bit-xor でメビウス変換","反転束において max でメビウス変換","反転束において min でメビウス変換","反転束において、<code>f</code> …","<code>f</code> を加法とするゼータ変換をします。"],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"f":[[[[1,[-1]]],2,[3,4]],[[[1,[-1]]],2,[3,5]],[[[1,[-1]]],2,[3,5]],[[[1,[-1]],-2,-1],[[6,[-1]]],3,7],[[[1,[-1]]],2,[3,8]],[[[1,[-1]]],2,[3,9]],[[[1,[-1]]],2,[3,10]],[[[1,[-1]],-2],2,[],7],[[[1,[-1]]],2,[3,11]],[[[1,[-1]]],2,[3,11]],[[[1,[-1]]],2,[3,4]],[[[1,[-1]]],2,[3,8]],[[[1,[-1]]],2,[3,9]],[[[1,[-1]]],2,[3,10]],[[[1,[-1]]],2,[3,11]],[[[1,[-1]]],2,[3,11]],[[[1,[-1]],-2],2,3,7],[[[1,[-1]],-2],2,3,7]],"c":[],"p":[[15,"slice"],[15,"tuple"],[8,"Copy",18],[8,"Add",19],[8,"Sub",19],[3,"Vec",20],[8,"Fn",21],[8,"BitAnd",22],[8,"BitOr",22],[8,"BitXor",22],[8,"Ord",23]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
